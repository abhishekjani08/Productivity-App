export default Spring;
/**
 * Provides a model of a classical spring acting to
 * resolve a body to equilibrium. Springs have configurable
 * tension which is a force multipler on the displacement of the
 * spring from its rest point or `endValue` as defined by [Hooke's
 * law](http://en.wikipedia.org/wiki/Hooke's_law). Springs also have
 * configurable friction, which ensures that they do not oscillate
 * infinitely. When a Spring is displaced by updating it's resting
 * or `currentValue`, the SpringSystems that contain that Spring
 * will automatically start looping to solve for equilibrium. As each
 * timestep passes, `SpringListener` objects attached to the Spring
 * will be notified of the updates providing a way to drive an
 * animation off of the spring's resolution curve.
 * @public
 */
declare class Spring {
    constructor(springSystem: any);
    _id: string;
    _springSystem: any;
    listeners: any[];
    _startValue: number;
    _currentState: PhysicsState;
    _displacementFromRestThreshold: number;
    _endValue: number;
    _overshootClampingEnabled: boolean;
    _previousState: PhysicsState;
    _restSpeedThreshold: number;
    _tempState: PhysicsState;
    _timeAccumulator: number;
    _wasAtRest: boolean;
    _cachedSpringConfig: {};
    getId(): string;
    /**
     * Remove a Spring from simulation and clear its listeners.
     * @public
     */
    public destroy(): void;
    /**
     * Set the configuration values for this Spring. A SpringConfig
     * contains the tension and friction values used to solve for the
     * equilibrium of the Spring in the physics loop.
     * @public
     */
    public setSpringConfig(springConfig: any): Spring;
    _springConfig: any;
    /**
     * Retrieve the current value of the Spring.
     * @public
     */
    public getCurrentValue(): number;
    /**
     * Get the absolute distance of the Spring from a given state value
     */
    getDisplacementDistanceForState(state: any): number;
    /**
     * Set the endValue or resting position of the spring. If this
     * value is different than the current value, the SpringSystem will
     * be notified and will begin running its solver loop to resolve
     * the Spring to equilibrium. Any listeners that are registered
     * for onSpringEndStateChange will also be notified of this update
     * immediately.
     * @public
     */
    public setEndValue(endValue: any): Spring;
    prevEndValue: any;
    /**
     * Set the current velocity of the Spring, in pixels per second. As
     * previously mentioned, this can be useful when you are performing
     * a direct manipulation gesture. When a UI element is released you
     * may call setVelocity on its animation Spring so that the Spring
     * continues with the same velocity as the gesture ended with. The
     * friction, tension, and displacement of the Spring will then
     * govern its motion to return to rest on a natural feeling curve.
     * @public
     */
    public setVelocity(velocity: any): Spring;
    setCurrentValue(currentValue: any): Spring;
    setAtRest(): Spring;
    /**
     * Enable overshoot clamping. This means that the Spring will stop
     * immediately when it reaches its resting position regardless of
     * any existing momentum it may have. This can be useful for certain
     * types of animations that should not oscillate such as a scale
     * down to 0 or alpha fade.
     * @public
     */
    public setOvershootClampingEnabled(enabled: any): Spring;
    /**
     * Check if the Spring has gone past its end point by comparing
     * the direction it was moving in when it started to the current
     * position and end value.
     * @public
     */
    public isOvershooting(): boolean;
    /**
     * The main solver method for the Spring. It takes
     * the current time and delta since the last time step and performs
     * an RK4 integration to get the new position and velocity state
     * for the Spring based on the tension, friction, velocity, and
     * displacement of the Spring.
     * @public
     */
    public advance(time: any, realDeltaTime: any): void;
    notifyPositionUpdated(notifyActivate: any, notifyAtRest: any): void;
    _onActivateCalled: boolean | undefined;
    /**
     * Check if the SpringSystem should advance. Springs are advanced
     * a final frame after they reach equilibrium to ensure that the
     * currentValue is exactly the requested endValue regardless of the
     * displacement threshold.
     * @public
     */
    public systemShouldAdvance(): boolean;
    wasAtRest(): boolean;
    /**
     * Check if the Spring is atRest meaning that it's currentValue and
     * endValue are the same and that it has no velocity. The previously
     * described thresholds for speed and displacement define the bounds
     * of this equivalence check. If the Spring has 0 tension, then it will
     * be considered at rest whenever its absolute velocity drops below the
     * restSpeedThreshold.
     * @public
     */
    public isAtRest(): boolean;
    _interpolate(alpha: any): void;
    addListener(newListener: any): Spring;
    addOneTimeListener(newListener: any): Spring;
    removeListener(listenerToRemove: any): Spring;
}
declare class PhysicsState {
    position: number;
    velocity: number;
}
