import{parse as t,translateX as e,translateY as i,scaleX as n,scaleY as s,multiply as r}from"rematrix";const a=t=>"number"==typeof t,o=t=>"function"==typeof t,l=t=>"[object Object]"===Object.prototype.toString.call(t),p=t=>Array.prototype.slice.apply(t),d=t=>{const e=t.reduce((t,e)=>(t[e]=(t[e]||0)+1,t),{});return Object.keys(e).filter(t=>e[t]>1)};function h(t,...e){return e.forEach(e=>{if(e)for(const i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i])}),t}const c=(t,e,i)=>t+(e-t)*i;var g={__proto__:null,isNumber:a,isFunction:o,isObject:l,toArray:p,getDuplicateValsAsStrings:d,assign:h,tweenProp:c},f={__proto__:null,DATA_FLIP_ID:"data-flip-id",DATA_INVERSE_FLIP_ID:"data-inverse-flip-id",DATA_FLIP_COMPONENT_ID:"data-flip-component-id",DATA_FLIP_CONFIG:"data-flip-config",DATA_PORTAL_KEY:"data-portal-key",DATA_EXIT_CONTAINER:"data-exit-container"};const m={noWobble:{stiffness:200,damping:26},gentle:{stiffness:120,damping:14},veryGentle:{stiffness:130,damping:17},wobbly:{stiffness:180,damping:12},stiff:{stiffness:260,damping:26}},u=t=>l(t)?t:Object.keys(m).indexOf(t)>-1?m[t]:{};let y;"undefined"!=typeof window&&(y=window.requestAnimationFrame),y=y||function(t){window.setTimeout(t,1e3/60)};var _=y;const S=Date.now(),E="object"==typeof performance&&"function"==typeof performance.now?()=>performance.now():()=>Date.now()-S;function v(t,e){const i=t.indexOf(e);-1!==i&&t.splice(i,1)}class A{run(){_(()=>{this.springSystem.loop(E())})}}class C{constructor(){this.position=0,this.velocity=0}}let b=0;class I{constructor(t){this._id="s"+b++,this._springSystem=t,this.listeners=[],this._startValue=0,this._currentState=new C,this._displacementFromRestThreshold=.001,this._endValue=0,this._overshootClampingEnabled=!1,this._previousState=new C,this._restSpeedThreshold=.001,this._tempState=new C,this._timeAccumulator=0,this._wasAtRest=!0,this._cachedSpringConfig={}}getId(){return this._id}destroy(){this.listeners=[],this._springSystem.deregisterSpring(this)}setSpringConfig(t){return this._springConfig=t,this}getCurrentValue(){return this._currentState.position}getDisplacementDistanceForState(t){return Math.abs(this._endValue-t.position)}setEndValue(t){if(t===this._endValue)return this;if(this.prevEndValue=t,this._endValue===t&&this.isAtRest())return this;this._startValue=this.getCurrentValue(),this._endValue=t,this._springSystem.activateSpring(this.getId());for(let t=0,e=this.listeners.length;t<e;t++){const e=this.listeners[t].onSpringEndStateChange;e&&e(this)}return this}setVelocity(t){return t===this._currentState.velocity||(this._currentState.velocity=t,this._springSystem.activateSpring(this.getId())),this}setCurrentValue(t){this._startValue=t,this._currentState.position=t;for(var e=0,i=this.listeners.length;e<i;e++){var n=this.listeners[e];n.onSpringUpdate&&n.onSpringUpdate(this)}return this}setAtRest(){return this._endValue=this._currentState.position,this._tempState.position=this._currentState.position,this._currentState.velocity=0,this}setOvershootClampingEnabled(t){return this._overshootClampingEnabled=t,this}isOvershooting(){const t=this._startValue,e=this._endValue;return this._springConfig.tension>0&&(t<e&&this.getCurrentValue()>e||t>e&&this.getCurrentValue()<e)}advance(t,e){let i=this.isAtRest();if(i&&this._wasAtRest)return;let n=e;e>.064&&(n=.064),this._timeAccumulator+=n;const s=this._springConfig.tension,r=this._springConfig.friction;let a,o,l,p,d,h,c,g,f,m,u=this._currentState.position,y=this._currentState.velocity,_=this._tempState.position,S=this._tempState.velocity;for(;this._timeAccumulator>=.001;)this._timeAccumulator-=.001,this._timeAccumulator<.001&&(this._previousState.position=u,this._previousState.velocity=y),a=y,o=s*(this._endValue-_)-r*y,_=u+.001*a*.5,S=y+.001*o*.5,l=S,p=s*(this._endValue-_)-r*S,_=u+.001*l*.5,S=y+.001*p*.5,d=S,h=s*(this._endValue-_)-r*S,_=u+.001*d,S=y+.001*h,c=S,g=s*(this._endValue-_)-r*S,f=1/6*(a+2*(l+d)+c),m=1/6*(o+2*(p+h)+g),u+=.001*f,y+=.001*m;this._tempState.position=_,this._tempState.velocity=S,this._currentState.position=u,this._currentState.velocity=y,this._timeAccumulator>0&&this._interpolate(this._timeAccumulator/.001),(this.isAtRest()||this._overshootClampingEnabled&&this.isOvershooting())&&(this._springConfig.tension>0?(this._startValue=this._endValue,this._currentState.position=this._endValue):(this._endValue=this._currentState.position,this._startValue=this._endValue),this.setVelocity(0),i=!0);let E=!1;this._wasAtRest&&(this._wasAtRest=!1,E=!0);let v=!1;i&&(this._wasAtRest=!0,v=!0),this.notifyPositionUpdated(E,v)}notifyPositionUpdated(t,e){this.listeners.filter(Boolean).forEach(i=>{t&&i.onSpringActivate&&!this._onActivateCalled&&(i.onSpringActivate(this),this._onActivateCalled=!0),i.onSpringUpdate&&i.onSpringUpdate(this),e&&i.onSpringAtRest&&i.onSpringAtRest(this)})}systemShouldAdvance(){return!this.isAtRest()||!this.wasAtRest()}wasAtRest(){return this._wasAtRest}isAtRest(){return Math.abs(this._currentState.velocity)<this._restSpeedThreshold&&(this.getDisplacementDistanceForState(this._currentState)<=this._displacementFromRestThreshold||0===this._springConfig.tension)}_interpolate(t){this._currentState.position=this._currentState.position*t+this._previousState.position*(1-t),this._currentState.velocity=this._currentState.velocity*t+this._previousState.velocity*(1-t)}addListener(t){return this.listeners.push(t),this}addOneTimeListener(t){const e=e=>(...i)=>{e(...i),this.removeListener(t)};return Object.keys(t).forEach(i=>{t[i]=e(t[i])}),this.listeners.push(t),this}removeListener(t){return v(this.listeners,t),this}}class O{constructor(t){this.looper=t||new A,this.looper.springSystem=this,this.listeners=[],this._activeSprings=[],this._idleSpringIndices=[],this._isIdle=!0,this._lastTimeMillis=-1,this._springRegistry={}}createSpring(t,e){return this.createSpringWithConfig({tension:t,friction:e})}createSpringWithConfig(t){const e=new I(this);return this.registerSpring(e),e.setSpringConfig(t),e}getIsIdle(){return this._isIdle}registerSpring(t){this._springRegistry[t.getId()]=t}deregisterSpring(t){v(this._activeSprings,t),delete this._springRegistry[t.getId()]}advance(t,e){for(;this._idleSpringIndices.length>0;)this._idleSpringIndices.pop();for(this._activeSprings.filter(Boolean).forEach(i=>{i.systemShouldAdvance()?i.advance(t/1e3,e/1e3):this._idleSpringIndices.push(this._activeSprings.indexOf(i))});this._idleSpringIndices.length>0;){const t=this._idleSpringIndices.pop();t>=0&&this._activeSprings.splice(t,1)}}loop(t){let e;-1===this._lastTimeMillis&&(this._lastTimeMillis=t-1);const i=t-this._lastTimeMillis;this._lastTimeMillis=t;let n=0;const s=this.listeners.length;for(n=0;n<s;n++)e=this.listeners[n],e.onBeforeIntegrate&&e.onBeforeIntegrate(this);for(this.advance(t,i),0===this._activeSprings.length&&(this._isIdle=!0,this._lastTimeMillis=-1),n=0;n<s;n++)e=this.listeners[n],e.onAfterIntegrate&&e.onAfterIntegrate(this);this._isIdle||this.looper.run()}activateSpring(t){const e=this._springRegistry[t];-1===this._activeSprings.indexOf(e)&&this._activeSprings.push(e),this.getIsIdle()&&(this._isIdle=!1,this.looper.run())}}const w=new O,x=t=>{const{springConfig:{stiffness:e,damping:i,overshootClamping:n},getOnUpdateFunc:s,onAnimationEnd:r,onSpringActivate:a}=t,o=w.createSpring(e,i);o.setOvershootClampingEnabled(!!n);const l={onSpringActivate:a,onSpringAtRest:()=>{o.destroy(),r()},onSpringUpdate:s({spring:o,onAnimationEnd:r})};return o.addListener(l),o},U=t=>{const e=x(t);return e.setEndValue(1),e},V=(t,e={})=>{if(!t||!t.length)return;e.reverse&&t.reverse();const i="number"!=typeof(n=e.speed)?1.1:1+Math.min(Math.max(5*n,0),5);var n;const s=1/Math.max(Math.min(t.length,100),10),r=t.map((t,e)=>{const n=t.getOnUpdateFunc;return t.getOnUpdateFunc=t=>{const a=n(t);return t=>{let n=t.getCurrentValue();n=n<.01?0:n>.99?1:n,n>=s&&r[e+1]&&r[e+1](Math.max(Math.min(n*i,1),0)),a(t)}},t}).map(t=>{const e=x(t);if(e)return e.setEndValue.bind(e)}).filter(Boolean);r[0]&&r[0](1)},F=t=>[0,1,4,5,12,13].map(e=>t[e]),P=({top:t,bottom:e,left:i,right:n})=>t<window.innerHeight&&e>0&&i<window.innerWidth&&n>0;function R(t){return JSON.parse(t.dataset.flipConfig||"{}")}const T=(t,e)=>h(t,{[e[0]]:e[1]}),D=(t,e)=>p(e?document.querySelectorAll(`[data-portal-key="${e}"]`):t.querySelectorAll("[data-flip-id]")),M=t=>t.map(t=>[t,t.getBoundingClientRect()]),k=({cachedOrderedFlipIds:l=[],inProgressAnimations:g={},flippedElementPositionsBeforeUpdate:f={},flipCallbacks:y={},containerEl:_,applyTransformOrigin:S,spring:E,debug:v,portalKey:A,staggerConfig:C={},decisionData:b={},handleEnterUpdateDelete:I,onComplete:O,onStart:w})=>{const x=(({element:t,portalKey:e})=>M(D(t,e)).map(([t,e])=>{const i=window.getComputedStyle(t);return[t.dataset.flipId,{element:t,rect:e,opacity:parseFloat(i.opacity),transform:i.transform}]}).reduce(T,{}))({element:_,portalKey:A}),k=(({containerEl:t,portalKey:e})=>e?(t=>e=>p(document.querySelectorAll(`[data-portal-key="${t}"]${e}`)))(e):t?(t=>{const e=Math.random().toFixed(5);return t.dataset.flipperId=e,i=>p(t.querySelectorAll(`[data-flipper-id="${e}"] ${i}`))})(t):()=>[])({containerEl:_,portalKey:A}),j=(t=>e=>t(`[data-flip-id="${e}"]`)[0])(k),B=t=>f[t]&&x[t],N=Object.keys(f).concat(Object.keys(x)).filter(t=>!B(t)),$={flipCallbacks:y,getElement:j,flippedElementPositionsBeforeUpdate:f,flippedElementPositionsAfterUpdate:x,inProgressAnimations:g,decisionData:b},L=h({},$,{unflippedIds:N}),{hideEnteringElements:q,animateEnteringElements:W,animateExitingElements:K}=(({unflippedIds:t,flipCallbacks:e,getElement:i,flippedElementPositionsBeforeUpdate:n,flippedElementPositionsAfterUpdate:s,inProgressAnimations:r,decisionData:a})=>{const o=t.filter(t=>s[t]).filter(t=>e[t]&&e[t].onAppear),l=t.filter(t=>n[t]&&e[t]&&e[t].onExit);let p;const d=new Promise(t=>{p=t}),h=[];let c=0;const g=l.map((t,i)=>{const{domDataForExitAnimations:{element:s,parent:o,childPosition:{top:l,left:d,width:g,height:f}}}=n[t];"static"===getComputedStyle(o).position&&(o.style.position="relative"),s.style.transform="matrix(1, 0, 0, 1, 0, 0)",s.style.position="absolute",s.style.top=l+"px",s.style.left=d+"px",s.style.height=f+"px",s.style.width=g+"px";let m=h.filter(t=>t[0]===o)[0];m||(m=[o,document.createDocumentFragment()],h.push(m)),m[1].appendChild(s),c+=1;const u=()=>{try{o.removeChild(s)}catch(t){}finally{c-=1,0===c&&p()}};return r[t]={stop:u},()=>e[t].onExit(s,i,u,a)});return h.forEach(t=>{t[0].appendChild(t[1])}),g.length||p(),{hideEnteringElements:()=>{o.forEach(t=>{const e=i(t);e&&(e.style.opacity="0")})},animateEnteringElements:()=>{o.forEach((t,n)=>{const s=i(t);s&&e[t].onAppear(s,n,a)})},animateExitingElements:()=>(g.forEach(t=>t()),d)}})(L),X=h({},$,{containerEl:_,flippedIds:l.filter(B),applyTransformOrigin:S,spring:E,debug:v,staggerConfig:C,scopedSelector:k,onComplete:O});w&&w(_,b);const Y=(({flippedIds:l,flipCallbacks:g,inProgressAnimations:f,flippedElementPositionsBeforeUpdate:y,flippedElementPositionsAfterUpdate:_,applyTransformOrigin:S,spring:E,getElement:v,debug:A,staggerConfig:C={},decisionData:b={},onComplete:I,containerEl:O})=>{let w;const x=new Promise(t=>{w=t});if(I&&x.then(()=>I(O,b)),!l.length)return()=>(w([]),x);const T=[],D=v(l[0]),M=D?D.ownerDocument.querySelector("body"):document.querySelector("body"),k=(d(l),l.map(l=>{const d=y[l].rect,v=_[l].rect,A=y[l].opacity,C=_[l].opacity,I=v.width<1||v.height<1,O=_[l].element;if(!P(d)&&!P(v))return!1;if(!O)return!1;const x=R(O),U=(({flipperSpring:t,flippedSpring:e}={})=>h({},m.noWobble,u(t),u(e)))({flipperSpring:E,flippedSpring:x.spring}),V=!0===x.stagger?"default":x.stagger,D={element:O,id:l,stagger:V,springConfig:U};if(g[l]&&g[l].shouldFlip&&!g[l].shouldFlip(b.previous,b.current))return!1;const j=Math.abs(d.left-v.left)+Math.abs(d.top-v.top),B=Math.abs(d.width-v.width)+Math.abs(d.height-v.height),N=Math.abs(C-A);if(0===d.height&&0===v.height||0===d.width&&0===v.width||j<.5&&B<.5&&N<.01)return!1;const $=t(_[l].transform),L={matrix:$},q={matrix:[]},W=[$];x.translate&&(W.push(e(d.left-v.left)),W.push(i(d.top-v.top))),x.scale&&(W.push(n(Math.max(d.width,1)/Math.max(v.width,1))),W.push(s(Math.max(d.height,1)/Math.max(v.height,1)))),x.opacity&&(q.opacity=A,L.opacity=C);let K=[];if(!g[l]||!g[l].shouldInvert||g[l].shouldInvert(b.previous,b.current)){const t=((t,e)=>p(t.querySelectorAll(`[data-inverse-flip-id="${e}"]`)))(O,l);K=t.map(t=>[t,R(t)])}q.matrix=F(W.reduce(r)),L.matrix=F(L.matrix);const X=(({element:t,invertedChildren:e,body:i})=>({matrix:n,opacity:s,forceMinVals:r})=>{if(a(s)&&(t.style.opacity=s+""),r&&(t.style.minHeight="1px",t.style.minWidth="1px"),!n)return;const o=(t=>`matrix(${t.join(", ")})`)(n);t.style.transform=o,e&&(({invertedChildren:t,matrix:e,body:i})=>{t.forEach(([t,n])=>{if(!i.contains(t))return;const s=e[0],r=e[3],a=e[5],o={translateX:0,translateY:0,scaleX:1,scaleY:1};let l="";n.translate&&(o.translateX=-e[4]/s,o.translateY=-a/r,l+=`translate(${o.translateX}px, ${o.translateY}px)`),n.scale&&(o.scaleX=1/s,o.scaleY=1/r,l+=` scale(${o.scaleX}, ${o.scaleY})`),t.style.transform=l})})({invertedChildren:e,matrix:n,body:i})})({element:O,invertedChildren:K,body:M});let Y;if(g[l]&&g[l].onComplete){const t=g[l].onComplete;Y=()=>t(O,b)}const H=a(q.opacity)&&a(L.opacity)&&q.opacity!==L.opacity;let J=!1;return h({},D,{stagger:V,springConfig:U,getOnUpdateFunc:({spring:t,onAnimationEnd:e})=>(f[l]={destroy:t.destroy.bind(t),onAnimationEnd:e},t=>{g[l]&&g[l].onSpringUpdate&&g[l].onSpringUpdate(t.getCurrentValue()),J||(J=!0,g[l]&&g[l].onStart&&g[l].onStart(O,b));const e=t.getCurrentValue();if(!M.contains(O))return void t.destroy();const i={matrix:[]};i.matrix=q.matrix.map((t,i)=>c(t,L.matrix[i],e)),H&&(i.opacity=c(q.opacity,L.opacity,e)),X(i)}),initializeFlip:()=>{X({matrix:q.matrix,opacity:H?q.opacity:void 0,forceMinVals:I}),g[l]&&g[l].onStartImmediate&&g[l].onStartImmediate(O,b),x.transformOrigin?O.style.transformOrigin=x.transformOrigin:S&&(O.style.transformOrigin="0 0"),K.forEach(([t,e])=>{e.transformOrigin?t.style.transformOrigin=e.transformOrigin:S&&(t.style.transformOrigin="0 0")})},onAnimationEnd:t=>{delete f[l],o(Y)&&Y(),O.style.transform="",K.forEach(([t])=>{t.style.transform=""}),I&&O&&(O.style.minHeight="",O.style.minWidth=""),t||(T.push(l),T.length>=k.length&&w(T))},delayUntil:x.delayUntil})}).filter(Boolean));if(k.forEach(({initializeFlip:t})=>t()),A)return()=>{};const j=k.filter(t=>{return t.delayUntil&&(e=t.delayUntil,k.filter(t=>t.id===e).length);var e}),B={},N={},$={};j.forEach(t=>{t.stagger?($[t.stagger]=!0,N[t.delayUntil]?N[t.delayUntil].push(t.stagger):N[t.delayUntil]=[t.stagger]):B[t.delayUntil]?B[t.delayUntil].push(t):B[t.delayUntil]=[t]});const L=k.filter(t=>t.stagger).reduce((t,e)=>(t[e.stagger]?t[e.stagger].push(e):t[e.stagger]=[e],t),{}),q=k.filter(t=>-1===j.indexOf(t));return q.forEach(t=>{t.onSpringActivate=()=>{B[t.id]&&B[t.id].forEach(U),N[t.id]&&Object.keys(N[t.id].reduce((t,e)=>h(t,{[e]:!0}),{})).forEach(t=>{V(L[t],C[t])})}}),()=>(k.length||w([]),q.filter(t=>!t.stagger).forEach(U),Object.keys(L).forEach(t=>{$[t]||V(L[t],C[t])}),x)})(X);I?I({hideEnteringElements:q,animateEnteringElements:W,animateExitingElements:K,animateFlippedElements:Y}):(q(),K().then(W),Y())},j=({element:t,flipCallbacks:e={},inProgressAnimations:i={},portalKey:n})=>{const s=D(t,n),r=p(t.querySelectorAll("[data-inverse-flip-id]")),a={},o=[],l={};s.filter(t=>e&&e[t.dataset.flipId]&&e[t.dataset.flipId].onExit).forEach(t=>{let e=t.parentNode;if(t.closest){const i=t.closest("[data-exit-container]");i&&(e=i)}let i=o.findIndex(t=>t[0]===e);-1===i&&(o.push([e,e.getBoundingClientRect()]),i=o.length-1),a[t.dataset.flipId]=o[i][1],l[t.dataset.flipId]=e});const d=M(s),c=d.map(([t,i])=>{const n={};if(e&&e[t.dataset.flipId]&&e[t.dataset.flipId].onExit){const e=a[t.dataset.flipId];h(n,{element:t,parent:l[t.dataset.flipId],childPosition:{top:i.top-e.top,left:i.left-e.left,width:i.width,height:i.height}})}return[t.dataset.flipId,{rect:i,opacity:parseFloat(window.getComputedStyle(t).opacity||"1"),domDataForExitAnimations:n}]}).reduce(T,{});var g,f;return g=i,f=s.concat(r),Object.keys(g).forEach(t=>{g[t].destroy&&g[t].destroy(),g[t].onAnimationEnd&&g[t].onAnimationEnd(!0),delete g[t]}),f.forEach(t=>{t.style.transform="",t.style.opacity=""}),{flippedElementPositions:c,cachedOrderedFlipIds:d.map(([t])=>t.dataset.flipId)}};class B{constructor(t){this.applyTransformOrigin=!0,h(this,t),this.inProgressAnimations={},this.flipCallbacks={},this.recordBeforeUpdate=this.recordBeforeUpdate.bind(this),this.update=this.update.bind(this),this.addFlipped=this.addFlipped.bind(this),this.addInverted=this.addInverted.bind(this)}recordBeforeUpdate(){this.snapshot=j({element:this.element,flipCallbacks:this.flipCallbacks,inProgressAnimations:this.inProgressAnimations})}update(t,e){this.snapshot&&(k({flippedElementPositionsBeforeUpdate:this.snapshot.flippedElementPositions,cachedOrderedFlipIds:this.snapshot.cachedOrderedFlipIds,containerEl:this.element,inProgressAnimations:this.inProgressAnimations,flipCallbacks:this.flipCallbacks,applyTransformOrigin:this.applyTransformOrigin,spring:this.spring,debug:this.debug,staggerConfig:this.staggerConfig,handleEnterUpdateDelete:this.handleEnterUpdateDelete,decisionData:{previous:t,current:e},onComplete:this.onComplete,onStart:this.onStart}),delete this.snapshot)}addFlipped({element:t,flipId:e,opacity:i,translate:n,scale:s,transformOrigin:r,spring:a,stagger:o,delayUntil:l,onAppear:p,onStart:d,onSpringUpdate:c,onComplete:g,onExit:f,shouldFlip:m,shouldInvert:u}){if(!t)throw new Error("no element provided");if(!e)throw new Error("No flipId provided");const y={scale:s,translate:n,opacity:i,transformOrigin:r,spring:a,stagger:o,delayUntil:l};y.scale||y.translate||y.opacity||h(y,{translate:!0,scale:!0,opacity:!0}),e&&(t.dataset.flipId=String(e)),t.dataset.flipConfig=JSON.stringify(y),this.flipCallbacks[e]={shouldFlip:m,shouldInvert:u,onAppear:p,onStart:d,onSpringUpdate:c,onComplete:g,onExit:f}}addInverted({element:t,parent:e,opacity:i,translate:n,scale:s,transformOrigin:r}){if(!t)throw new Error("no element provided");if(!e)throw new Error("parent must be provided");const a=e.dataset.flipId,o={scale:s,translate:n,opacity:i,transformOrigin:r};o.scale||o.translate||o.opacity||h(o,{translate:!0,scale:!0,opacity:!0}),t.dataset.inverseFlipId=a,t.dataset.flipConfig=JSON.stringify(o)}}const N=new O,$=({config:t,values:e,onUpdate:i,delay:n=0,onComplete:s})=>{const{stiffness:r,damping:a,overshootClamping:o}=h({},m.noWobble,u(t)),l=N.createSpring(r,a);return l.setOvershootClampingEnabled(!!o),l.addListener({onSpringAtRest:t=>{s&&s(),t.destroy()},onSpringUpdate:t=>{const n=t.getCurrentValue();if(!e)return i(n);const s=Object.keys(e).map(t=>[t,c(e[t][0],e[t][1],n)]).reduce((t,e)=>Object.assign(t,{[e[0]]:e[1]}),{});i(s)}}),n?setTimeout(()=>{l.setEndValue(1)},n):l.setEndValue(1),l};export{B as Flipper,f as constants,j as getFlippedElementPositionsBeforeUpdate,k as onFlipKeyUpdate,$ as spring,g as utilities};
//# sourceMappingURL=index.modern.js.map
