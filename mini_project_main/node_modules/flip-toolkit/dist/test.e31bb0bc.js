// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"../src/utilities/index.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assign = assign;
exports.tweenProp = exports.getDuplicateValsAsStrings = exports.toArray = exports.isObject = exports.isFunction = exports.isNumber = void 0;

var isNumber = function isNumber(x) {
  return typeof x === 'number';
};

exports.isNumber = isNumber;

var isFunction = function isFunction(x) {
  return typeof x === 'function';
};

exports.isFunction = isFunction;

var isObject = function isObject(x) {
  return Object.prototype.toString.call(x) === '[object Object]';
};

exports.isObject = isObject;

var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.apply(arrayLike);
};

exports.toArray = toArray;

var getDuplicateValsAsStrings = function getDuplicateValsAsStrings(arr) {
  var baseObj = {};
  var obj = arr.reduce(function (acc, curr) {
    acc[curr] = (acc[curr] || 0) + 1;
    return acc;
  }, baseObj);
  return Object.keys(obj).filter(function (val) {
    return obj[val] > 1;
  });
}; // tslint only likes this with a regular function, not an arrow function


exports.getDuplicateValsAsStrings = getDuplicateValsAsStrings;

function assign(target) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  args.forEach(function (arg) {
    if (!arg) {
      return;
    } // Skip over if undefined or null


    for (var nextKey in arg) {
      // Avoid bugs when hasOwnProperty is shadowed
      if (Object.prototype.hasOwnProperty.call(arg, nextKey)) {
        target[nextKey] = arg[nextKey];
      }
    }
  });
  return target;
}

var tweenProp = function tweenProp(start, end, position) {
  return start + (end - start) * position;
};

exports.tweenProp = tweenProp;
},{}],"../src/constants.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DATA_EXIT_CONTAINER = exports.DATA_PORTAL_KEY = exports.DATA_FLIP_CONFIG = exports.DATA_FLIP_COMPONENT_ID = exports.DATA_INVERSE_FLIP_ID = exports.DATA_FLIP_ID = void 0;
var DATA_FLIP_ID = 'data-flip-id';
exports.DATA_FLIP_ID = DATA_FLIP_ID;
var DATA_INVERSE_FLIP_ID = 'data-inverse-flip-id';
exports.DATA_INVERSE_FLIP_ID = DATA_INVERSE_FLIP_ID;
var DATA_FLIP_COMPONENT_ID = 'data-flip-component-id';
exports.DATA_FLIP_COMPONENT_ID = DATA_FLIP_COMPONENT_ID;
var DATA_FLIP_CONFIG = 'data-flip-config';
exports.DATA_FLIP_CONFIG = DATA_FLIP_CONFIG;
var DATA_PORTAL_KEY = 'data-portal-key';
exports.DATA_PORTAL_KEY = DATA_PORTAL_KEY;
var DATA_EXIT_CONTAINER = 'data-exit-container';
exports.DATA_EXIT_CONTAINER = DATA_EXIT_CONTAINER;
},{}],"../src/flip/animateUnflippedElements/index.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var animateUnflippedElements = function animateUnflippedElements(_ref) {
  var unflippedIds = _ref.unflippedIds,
      flipCallbacks = _ref.flipCallbacks,
      getElement = _ref.getElement,
      flippedElementPositionsBeforeUpdate = _ref.flippedElementPositionsBeforeUpdate,
      flippedElementPositionsAfterUpdate = _ref.flippedElementPositionsAfterUpdate,
      inProgressAnimations = _ref.inProgressAnimations,
      decisionData = _ref.decisionData;
  var enteringElementIds = unflippedIds.filter(function (id) {
    return flippedElementPositionsAfterUpdate[id];
  });
  var animatedEnteringElementIds = enteringElementIds.filter(function (id) {
    return flipCallbacks[id] && flipCallbacks[id].onAppear;
  });
  var animatedExitingElementIds = unflippedIds.filter(function (id) {
    return flippedElementPositionsBeforeUpdate[id] && flipCallbacks[id] && flipCallbacks[id].onExit;
  });

  var hideEnteringElements = function hideEnteringElements() {
    animatedEnteringElementIds.forEach(function (id) {
      var element = getElement(id);

      if (element) {
        element.style.opacity = '0';
      }
    });
  };

  var animateEnteringElements = function animateEnteringElements() {
    animatedEnteringElementIds.forEach(function (id, i) {
      var element = getElement(id);

      if (element) {
        flipCallbacks[id].onAppear(element, i, decisionData);
      }
    });
  };

  var closureResolve;
  var promiseToReturn = new Promise(function (resolve) {
    closureResolve = resolve;
  });
  var fragmentTuples = [];
  var exitingElementCount = 0;
  var onExitCallbacks = animatedExitingElementIds.map(function (id, i) {
    var _flippedElementPositi = flippedElementPositionsBeforeUpdate[id].domDataForExitAnimations,
        element = _flippedElementPositi.element,
        parent = _flippedElementPositi.parent,
        _flippedElementPositi2 = _flippedElementPositi.childPosition,
        top = _flippedElementPositi2.top,
        left = _flippedElementPositi2.left,
        width = _flippedElementPositi2.width,
        height = _flippedElementPositi2.height; // insert back into dom

    if (getComputedStyle(parent).position === 'static') {
      parent.style.position = 'relative';
    }

    element.style.transform = 'matrix(1, 0, 0, 1, 0, 0)';
    element.style.position = 'absolute';
    element.style.top = top + 'px';
    element.style.left = left + 'px'; // taken out of the dom flow, the element might have lost these dimensions

    element.style.height = height + 'px';
    element.style.width = width + 'px';
    var fragmentTuple = fragmentTuples.filter(function (t) {
      return t[0] === parent;
    })[0];

    if (!fragmentTuple) {
      fragmentTuple = [parent, document.createDocumentFragment()];
      fragmentTuples.push(fragmentTuple);
    }

    fragmentTuple[1].appendChild(element);
    exitingElementCount += 1;

    var stop = function stop() {
      try {
        parent.removeChild(element);
      } catch (DOMException) {// the element is already gone
      } finally {
        exitingElementCount -= 1;

        if (exitingElementCount === 0) {
          closureResolve();
        }
      }
    }; // @ts-ignore


    inProgressAnimations[id] = {
      stop: stop
    };
    return function () {
      return flipCallbacks[id].onExit(element, i, stop, decisionData);
    };
  }); // now append all the fragments from the onExit callbacks
  // (we use fragments for performance)

  fragmentTuples.forEach(function (t) {
    t[0].appendChild(t[1]);
  });

  if (!onExitCallbacks.length) {
    closureResolve();
  }

  var animateExitingElements = function animateExitingElements() {
    onExitCallbacks.forEach(function (c) {
      return c();
    });
    return promiseToReturn;
  };

  return {
    hideEnteringElements: hideEnteringElements,
    animateEnteringElements: animateEnteringElements,
    animateExitingElements: animateExitingElements
  };
};

var _default = animateUnflippedElements;
exports.default = _default;
},{}],"../../../node_modules/rematrix/dist/rematrix.es.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.format = format;
exports.identity = identity;
exports.inverse = inverse;
exports.multiply = multiply;
exports.parse = parse;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.scale = scale;
exports.scaleX = scaleX;
exports.scaleY = scaleY;
exports.scaleZ = scaleZ;
exports.skew = skew;
exports.skewX = skewX;
exports.skewY = skewY;
exports.translate = translate;
exports.translateX = translateX;
exports.translateY = translateY;
exports.translateZ = translateZ;

/*! @license Rematrix v0.2.2

	Copyright 2018 Fisssion LLC.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
*/

/**
 * @module Rematrix
 */

/**
 * Transformation matrices in the browser come in two flavors:
 *
 *  - `matrix` using 6 values (short)
 *  - `matrix3d` using 16 values (long)
 *
 * This utility follows this [conversion guide](https://goo.gl/EJlUQ1)
 * to expand short form matrices to their equivalent long form.
 *
 * @param  {array} source - Accepts both short and long form matrices.
 * @return {array}
 */
function format(source) {
  if (source.constructor !== Array) {
    throw new TypeError('Expected array.');
  }

  if (source.length === 16) {
    return source;
  }

  if (source.length === 6) {
    var matrix = identity();
    matrix[0] = source[0];
    matrix[1] = source[1];
    matrix[4] = source[2];
    matrix[5] = source[3];
    matrix[12] = source[4];
    matrix[13] = source[5];
    return matrix;
  }

  throw new RangeError('Expected array with either 6 or 16 values.');
}
/**
 * Returns a matrix representing no transformation. The product of any matrix
 * multiplied by the identity matrix will be the original matrix.
 *
 * > **Tip:** Similar to how `5 * 1 === 5`, where `1` is the identity.
 *
 * @return {array}
 */


function identity() {
  var matrix = [];

  for (var i = 0; i < 16; i++) {
    i % 5 == 0 ? matrix.push(1) : matrix.push(0);
  }

  return matrix;
}
/**
 * Returns a matrix describing the inverse transformation of the source
 * matrix. The product of any matrix multiplied by its inverse will be the
 * identity matrix.
 *
 * > **Tip:** Similar to how `5 * (1/5) === 1`, where `1/5` is the inverse.
 *
 * @param  {array} source - Accepts both short and long form matrices.
 * @return {array}
 */


function inverse(source) {
  var m = format(source);
  var s0 = m[0] * m[5] - m[4] * m[1];
  var s1 = m[0] * m[6] - m[4] * m[2];
  var s2 = m[0] * m[7] - m[4] * m[3];
  var s3 = m[1] * m[6] - m[5] * m[2];
  var s4 = m[1] * m[7] - m[5] * m[3];
  var s5 = m[2] * m[7] - m[6] * m[3];
  var c5 = m[10] * m[15] - m[14] * m[11];
  var c4 = m[9] * m[15] - m[13] * m[11];
  var c3 = m[9] * m[14] - m[13] * m[10];
  var c2 = m[8] * m[15] - m[12] * m[11];
  var c1 = m[8] * m[14] - m[12] * m[10];
  var c0 = m[8] * m[13] - m[12] * m[9];
  var determinant = 1 / (s0 * c5 - s1 * c4 + s2 * c3 + s3 * c2 - s4 * c1 + s5 * c0);

  if (isNaN(determinant) || determinant === Infinity) {
    throw new Error('Inverse determinant attempted to divide by zero.');
  }

  return [(m[5] * c5 - m[6] * c4 + m[7] * c3) * determinant, (-m[1] * c5 + m[2] * c4 - m[3] * c3) * determinant, (m[13] * s5 - m[14] * s4 + m[15] * s3) * determinant, (-m[9] * s5 + m[10] * s4 - m[11] * s3) * determinant, (-m[4] * c5 + m[6] * c2 - m[7] * c1) * determinant, (m[0] * c5 - m[2] * c2 + m[3] * c1) * determinant, (-m[12] * s5 + m[14] * s2 - m[15] * s1) * determinant, (m[8] * s5 - m[10] * s2 + m[11] * s1) * determinant, (m[4] * c4 - m[5] * c2 + m[7] * c0) * determinant, (-m[0] * c4 + m[1] * c2 - m[3] * c0) * determinant, (m[12] * s4 - m[13] * s2 + m[15] * s0) * determinant, (-m[8] * s4 + m[9] * s2 - m[11] * s0) * determinant, (-m[4] * c3 + m[5] * c1 - m[6] * c0) * determinant, (m[0] * c3 - m[1] * c1 + m[2] * c0) * determinant, (-m[12] * s3 + m[13] * s1 - m[14] * s0) * determinant, (m[8] * s3 - m[9] * s1 + m[10] * s0) * determinant];
}
/**
 * Returns a 4x4 matrix describing the combined transformations
 * of both arguments.
 *
 * > **Note:** Order is very important. For example, rotating 45°
 * along the Z-axis, followed by translating 500 pixels along the
 * Y-axis... is not the same as translating 500 pixels along the
 * Y-axis, followed by rotating 45° along on the Z-axis.
 *
 * @param  {array} m - Accepts both short and long form matrices.
 * @param  {array} x - Accepts both short and long form matrices.
 * @return {array}
 */


function multiply(m, x) {
  var fm = format(m);
  var fx = format(x);
  var product = [];

  for (var i = 0; i < 4; i++) {
    var row = [fm[i], fm[i + 4], fm[i + 8], fm[i + 12]];

    for (var j = 0; j < 4; j++) {
      var k = j * 4;
      var col = [fx[k], fx[k + 1], fx[k + 2], fx[k + 3]];
      var result = row[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3];
      product[i + k] = result;
    }
  }

  return product;
}
/**
 * Attempts to return a 4x4 matrix describing the CSS transform
 * matrix passed in, but will return the identity matrix as a
 * fallback.
 *
 * **Tip:** In virtually all cases, this method is used to convert
 * a CSS matrix (retrieved as a `string` from computed styles) to
 * its equivalent array format.
 *
 * @param  {string} source - String containing a valid CSS `matrix` or `matrix3d` property.
 * @return {array}
 */


function parse(source) {
  if (typeof source === 'string') {
    var match = source.match(/matrix(3d)?\(([^)]+)\)/);

    if (match) {
      var raw = match[2].split(', ').map(parseFloat);
      return format(raw);
    }
  }

  return identity();
}
/**
 * Returns a 4x4 matrix describing Z-axis rotation.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */


function rotate(angle) {
  return rotateZ(angle);
}
/**
 * Returns a 4x4 matrix describing X-axis rotation.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */


function rotateX(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[5] = matrix[10] = Math.cos(theta);
  matrix[6] = matrix[9] = Math.sin(theta);
  matrix[9] *= -1;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Y-axis rotation.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */


function rotateY(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[0] = matrix[10] = Math.cos(theta);
  matrix[2] = matrix[8] = Math.sin(theta);
  matrix[2] *= -1;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Z-axis rotation.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */


function rotateZ(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[0] = matrix[5] = Math.cos(theta);
  matrix[1] = matrix[4] = Math.sin(theta);
  matrix[4] *= -1;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing 2D scaling. The first argument
 * is used for both X and Y-axis scaling, unless an optional
 * second argument is provided to explicitly define Y-axis scaling.
 *
 * @param  {number} scalar    - Decimal multiplier.
 * @param  {number} [scalarY] - Decimal multiplier.
 * @return {array}
 */


function scale(scalar, scalarY) {
  var matrix = identity();
  matrix[0] = scalar;
  matrix[5] = typeof scalarY === 'number' ? scalarY : scalar;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing X-axis scaling.
 *
 * @param  {number} scalar - Decimal multiplier.
 * @return {array}
 */


function scaleX(scalar) {
  var matrix = identity();
  matrix[0] = scalar;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Y-axis scaling.
 *
 * @param  {number} scalar - Decimal multiplier.
 * @return {array}
 */


function scaleY(scalar) {
  var matrix = identity();
  matrix[5] = scalar;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Z-axis scaling.
 *
 * @param  {number} scalar - Decimal multiplier.
 * @return {array}
 */


function scaleZ(scalar) {
  var matrix = identity();
  matrix[10] = scalar;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing shear. The first argument
 * defines X-axis shearing, and an optional second argument
 * defines Y-axis shearing.
 *
 * @param  {number} angleX   - Measured in degrees.
 * @param  {number} [angleY] - Measured in degrees.
 * @return {array}
 */


function skew(angleX, angleY) {
  var thetaX = Math.PI / 180 * angleX;
  var matrix = identity();
  matrix[4] = Math.tan(thetaX);

  if (angleY) {
    var thetaY = Math.PI / 180 * angleY;
    matrix[1] = Math.tan(thetaY);
  }

  return matrix;
}
/**
 * Returns a 4x4 matrix describing X-axis shear.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */


function skewX(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[4] = Math.tan(theta);
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Y-axis shear.
 *
 * @param  {number} angle - Measured in degrees
 * @return {array}
 */


function skewY(angle) {
  var theta = Math.PI / 180 * angle;
  var matrix = identity();
  matrix[1] = Math.tan(theta);
  return matrix;
}
/**
 * Returns a 4x4 matrix describing 2D translation. The first
 * argument defines X-axis translation, and an optional second
 * argument defines Y-axis translation.
 *
 * @param  {number} distanceX   - Measured in pixels.
 * @param  {number} [distanceY] - Measured in pixels.
 * @return {array}
 */


function translate(distanceX, distanceY) {
  var matrix = identity();
  matrix[12] = distanceX;

  if (distanceY) {
    matrix[13] = distanceY;
  }

  return matrix;
}
/**
 * Returns a 4x4 matrix describing X-axis translation.
 *
 * @param  {number} distance - Measured in pixels.
 * @return {array}
 */


function translateX(distance) {
  var matrix = identity();
  matrix[12] = distance;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Y-axis translation.
 *
 * @param  {number} distance - Measured in pixels.
 * @return {array}
 */


function translateY(distance) {
  var matrix = identity();
  matrix[13] = distance;
  return matrix;
}
/**
 * Returns a 4x4 matrix describing Z-axis translation.
 *
 * @param  {number} distance - Measured in pixels.
 * @return {array}
 */


function translateZ(distance) {
  var matrix = identity();
  matrix[14] = distance;
  return matrix;
}
},{}],"../src/springSettings/index.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSpringConfig = exports.normalizeSpring = exports.springPresets = void 0;

var _utilities = require("../utilities");

// adapted from
// https://github.com/chenglou/react-motion/blob/master/src/presets.js
var springPresets = {
  noWobble: {
    stiffness: 200,
    damping: 26
  },
  gentle: {
    stiffness: 120,
    damping: 14
  },
  veryGentle: {
    stiffness: 130,
    damping: 17
  },
  wobbly: {
    stiffness: 180,
    damping: 12
  },
  stiff: {
    stiffness: 260,
    damping: 26
  }
};
exports.springPresets = springPresets;

function argIsSpringConfig(arg) {
  return (0, _utilities.isObject)(arg);
}

var normalizeSpring = function normalizeSpring(spring) {
  if (argIsSpringConfig(spring)) {
    return spring;
  } else if (Object.keys(springPresets).indexOf(spring) > -1) {
    return springPresets[spring];
  } else {
    return {};
  }
};

exports.normalizeSpring = normalizeSpring;

var getSpringConfig = function getSpringConfig() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      flipperSpring = _ref.flipperSpring,
      flippedSpring = _ref.flippedSpring;

  return (0, _utilities.assign)({}, springPresets.noWobble, normalizeSpring(flipperSpring), normalizeSpring(flippedSpring));
};

exports.getSpringConfig = getSpringConfig;
},{"../utilities":"../src/utilities/index.ts"}],"../src/forked-rebound/onFrame.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 *  Copyright (c) 2013, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 *
 */
var _onFrame;

if (typeof window !== "undefined") {
  _onFrame = window.requestAnimationFrame;
}

_onFrame = _onFrame || function (callback) {
  window.setTimeout(callback, 1000 / 60);
};

var _default = _onFrame;
exports.default = _default;
},{}],"../src/forked-rebound/util.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeFirst = removeFirst;
Object.defineProperty(exports, "onFrame", {
  enumerable: true,
  get: function () {
    return _onFrame.default;
  }
});
exports.performanceNow = void 0;

var _onFrame = _interopRequireDefault(require("./onFrame"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var start = Date.now();
var performanceNow = (typeof performance === "undefined" ? "undefined" : _typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {
  return performance.now();
} : function () {
  return Date.now() - start;
}; // Lop off the first occurence of the reference in the Array.

exports.performanceNow = performanceNow;

function removeFirst(array, item) {
  var idx = array.indexOf(item);
  idx !== -1 && array.splice(idx, 1);
}
},{"./onFrame":"../src/forked-rebound/onFrame.js"}],"../src/forked-rebound/Loopers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimationLooper = void 0;

var _util = require("./util");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Plays each frame of the SpringSystem on animation
 * timing loop. This is the default type of looper for a new spring system
 * as it is the most common when developing UI.
 * @public
 */
var AnimationLooper = /*#__PURE__*/function () {
  function AnimationLooper() {
    _classCallCheck(this, AnimationLooper);
  }

  _createClass(AnimationLooper, [{
    key: "run",
    value: function run() {
      var _this = this;

      (0, _util.onFrame)(function () {
        _this.springSystem.loop((0, _util.performanceNow)());
      });
    }
  }]);

  return AnimationLooper;
}();

exports.AnimationLooper = AnimationLooper;
},{"./util":"../src/forked-rebound/util.js"}],"../src/forked-rebound/Spring.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("./util");

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PhysicsState = function PhysicsState() {
  _classCallCheck(this, PhysicsState);

  this.position = 0;
  this.velocity = 0;
};

var ID = 0;
var MAX_DELTA_TIME_SEC = 0.064;
var SOLVER_TIMESTEP_SEC = 0.001;
/**
 * Provides a model of a classical spring acting to
 * resolve a body to equilibrium. Springs have configurable
 * tension which is a force multipler on the displacement of the
 * spring from its rest point or `endValue` as defined by [Hooke's
 * law](http://en.wikipedia.org/wiki/Hooke's_law). Springs also have
 * configurable friction, which ensures that they do not oscillate
 * infinitely. When a Spring is displaced by updating it's resting
 * or `currentValue`, the SpringSystems that contain that Spring
 * will automatically start looping to solve for equilibrium. As each
 * timestep passes, `SpringListener` objects attached to the Spring
 * will be notified of the updates providing a way to drive an
 * animation off of the spring's resolution curve.
 * @public
 */

var Spring = /*#__PURE__*/function () {
  function Spring(springSystem) {
    _classCallCheck(this, Spring);

    this._id = "s".concat(ID++);
    this._springSystem = springSystem;
    this.listeners = [];
    this._startValue = 0;
    this._currentState = new PhysicsState();
    this._displacementFromRestThreshold = 0.001;
    this._endValue = 0;
    this._overshootClampingEnabled = false;
    this._previousState = new PhysicsState();
    this._restSpeedThreshold = 0.001;
    this._tempState = new PhysicsState();
    this._timeAccumulator = 0;
    this._wasAtRest = true; // hack from alex -- only call 1x

    this._onActivateCalled;
    this._cachedSpringConfig = {};
  }

  _createClass(Spring, [{
    key: "getId",
    value: function getId() {
      return this._id;
    }
    /**
     * Remove a Spring from simulation and clear its listeners.
     * @public
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.listeners = [];

      this._springSystem.deregisterSpring(this);
    }
    /**
     * Set the configuration values for this Spring. A SpringConfig
     * contains the tension and friction values used to solve for the
     * equilibrium of the Spring in the physics loop.
     * @public
     */

  }, {
    key: "setSpringConfig",
    value: function setSpringConfig(springConfig) {
      this._springConfig = springConfig;
      return this;
    }
    /**
     * Retrieve the current value of the Spring.
     * @public
     */

  }, {
    key: "getCurrentValue",
    value: function getCurrentValue() {
      return this._currentState.position;
    }
    /**
     * Get the absolute distance of the Spring from a given state value
     */

  }, {
    key: "getDisplacementDistanceForState",
    value: function getDisplacementDistanceForState(state) {
      return Math.abs(this._endValue - state.position);
    }
    /**
     * Set the endValue or resting position of the spring. If this
     * value is different than the current value, the SpringSystem will
     * be notified and will begin running its solver loop to resolve
     * the Spring to equilibrium. Any listeners that are registered
     * for onSpringEndStateChange will also be notified of this update
     * immediately.
     * @public
     */

  }, {
    key: "setEndValue",
    value: function setEndValue(endValue) {
      if (endValue === this._endValue) return this;
      this.prevEndValue = endValue;

      if (this._endValue === endValue && this.isAtRest()) {
        return this;
      }

      this._startValue = this.getCurrentValue();
      this._endValue = endValue;

      this._springSystem.activateSpring(this.getId());

      for (var i = 0, len = this.listeners.length; i < len; i++) {
        var listener = this.listeners[i];
        var onChange = listener.onSpringEndStateChange;
        onChange && onChange(this);
      }

      return this;
    }
    /**
     * Set the current velocity of the Spring, in pixels per second. As
     * previously mentioned, this can be useful when you are performing
     * a direct manipulation gesture. When a UI element is released you
     * may call setVelocity on its animation Spring so that the Spring
     * continues with the same velocity as the gesture ended with. The
     * friction, tension, and displacement of the Spring will then
     * govern its motion to return to rest on a natural feeling curve.
     * @public
     */

  }, {
    key: "setVelocity",
    value: function setVelocity(velocity) {
      if (velocity === this._currentState.velocity) {
        return this;
      }

      this._currentState.velocity = velocity;

      this._springSystem.activateSpring(this.getId());

      return this;
    }
  }, {
    key: "setCurrentValue",
    value: function setCurrentValue(currentValue) {
      this._startValue = currentValue;
      this._currentState.position = currentValue;

      for (var i = 0, len = this.listeners.length; i < len; i++) {
        var listener = this.listeners[i];
        listener.onSpringUpdate && listener.onSpringUpdate(this);
      }

      return this;
    }
  }, {
    key: "setAtRest",
    value: function setAtRest() {
      this._endValue = this._currentState.position;
      this._tempState.position = this._currentState.position;
      this._currentState.velocity = 0;
      return this;
    }
    /**
     * Enable overshoot clamping. This means that the Spring will stop
     * immediately when it reaches its resting position regardless of
     * any existing momentum it may have. This can be useful for certain
     * types of animations that should not oscillate such as a scale
     * down to 0 or alpha fade.
     * @public
     */

  }, {
    key: "setOvershootClampingEnabled",
    value: function setOvershootClampingEnabled(enabled) {
      this._overshootClampingEnabled = enabled;
      return this;
    }
    /**
     * Check if the Spring has gone past its end point by comparing
     * the direction it was moving in when it started to the current
     * position and end value.
     * @public
     */

  }, {
    key: "isOvershooting",
    value: function isOvershooting() {
      var start = this._startValue;
      var end = this._endValue;
      return this._springConfig.tension > 0 && (start < end && this.getCurrentValue() > end || start > end && this.getCurrentValue() < end);
    }
    /**
     * The main solver method for the Spring. It takes
     * the current time and delta since the last time step and performs
     * an RK4 integration to get the new position and velocity state
     * for the Spring based on the tension, friction, velocity, and
     * displacement of the Spring.
     * @public
     */

  }, {
    key: "advance",
    value: function advance(time, realDeltaTime) {
      var isAtRest = this.isAtRest();

      if (isAtRest && this._wasAtRest) {
        return;
      }

      var adjustedDeltaTime = realDeltaTime;

      if (realDeltaTime > MAX_DELTA_TIME_SEC) {
        adjustedDeltaTime = MAX_DELTA_TIME_SEC;
      }

      this._timeAccumulator += adjustedDeltaTime;
      var tension = this._springConfig.tension;
      var friction = this._springConfig.friction;
      var position = this._currentState.position;
      var velocity = this._currentState.velocity;
      var tempPosition = this._tempState.position;
      var tempVelocity = this._tempState.velocity;
      var aVelocity;
      var aAcceleration;
      var bVelocity;
      var bAcceleration;
      var cVelocity;
      var cAcceleration;
      var dVelocity;
      var dAcceleration;
      var dxdt;
      var dvdt;

      while (this._timeAccumulator >= SOLVER_TIMESTEP_SEC) {
        this._timeAccumulator -= SOLVER_TIMESTEP_SEC;

        if (this._timeAccumulator < SOLVER_TIMESTEP_SEC) {
          this._previousState.position = position;
          this._previousState.velocity = velocity;
        }

        aVelocity = velocity;
        aAcceleration = tension * (this._endValue - tempPosition) - friction * velocity;
        tempPosition = position + aVelocity * SOLVER_TIMESTEP_SEC * 0.5;
        tempVelocity = velocity + aAcceleration * SOLVER_TIMESTEP_SEC * 0.5;
        bVelocity = tempVelocity;
        bAcceleration = tension * (this._endValue - tempPosition) - friction * tempVelocity;
        tempPosition = position + bVelocity * SOLVER_TIMESTEP_SEC * 0.5;
        tempVelocity = velocity + bAcceleration * SOLVER_TIMESTEP_SEC * 0.5;
        cVelocity = tempVelocity;
        cAcceleration = tension * (this._endValue - tempPosition) - friction * tempVelocity;
        tempPosition = position + cVelocity * SOLVER_TIMESTEP_SEC;
        tempVelocity = velocity + cAcceleration * SOLVER_TIMESTEP_SEC;
        dVelocity = tempVelocity;
        dAcceleration = tension * (this._endValue - tempPosition) - friction * tempVelocity;
        dxdt = 1.0 / 6.0 * (aVelocity + 2.0 * (bVelocity + cVelocity) + dVelocity);
        dvdt = 1.0 / 6.0 * (aAcceleration + 2.0 * (bAcceleration + cAcceleration) + dAcceleration);
        position += dxdt * SOLVER_TIMESTEP_SEC;
        velocity += dvdt * SOLVER_TIMESTEP_SEC;
      }

      this._tempState.position = tempPosition;
      this._tempState.velocity = tempVelocity;
      this._currentState.position = position;
      this._currentState.velocity = velocity;

      if (this._timeAccumulator > 0) {
        this._interpolate(this._timeAccumulator / SOLVER_TIMESTEP_SEC);
      }

      if (this.isAtRest() || this._overshootClampingEnabled && this.isOvershooting()) {
        if (this._springConfig.tension > 0) {
          this._startValue = this._endValue;
          this._currentState.position = this._endValue;
        } else {
          this._endValue = this._currentState.position;
          this._startValue = this._endValue;
        }

        this.setVelocity(0);
        isAtRest = true;
      }

      var notifyActivate = false;

      if (this._wasAtRest) {
        this._wasAtRest = false;
        notifyActivate = true;
      }

      var notifyAtRest = false;

      if (isAtRest) {
        this._wasAtRest = true;
        notifyAtRest = true;
      }

      this.notifyPositionUpdated(notifyActivate, notifyAtRest);
    }
  }, {
    key: "notifyPositionUpdated",
    value: function notifyPositionUpdated(notifyActivate, notifyAtRest) {
      var _this = this;

      this.listeners.filter(Boolean).forEach(function (listener) {
        if (notifyActivate && listener.onSpringActivate && !_this._onActivateCalled) {
          listener.onSpringActivate(_this);
          _this._onActivateCalled = true;
        }

        if (listener.onSpringUpdate) {
          listener.onSpringUpdate(_this);
        }

        if (notifyAtRest && listener.onSpringAtRest) {
          listener.onSpringAtRest(_this);
        }
      });
    }
    /**
     * Check if the SpringSystem should advance. Springs are advanced
     * a final frame after they reach equilibrium to ensure that the
     * currentValue is exactly the requested endValue regardless of the
     * displacement threshold.
     * @public
     */

  }, {
    key: "systemShouldAdvance",
    value: function systemShouldAdvance() {
      return !this.isAtRest() || !this.wasAtRest();
    }
  }, {
    key: "wasAtRest",
    value: function wasAtRest() {
      return this._wasAtRest;
    }
    /**
     * Check if the Spring is atRest meaning that it's currentValue and
     * endValue are the same and that it has no velocity. The previously
     * described thresholds for speed and displacement define the bounds
     * of this equivalence check. If the Spring has 0 tension, then it will
     * be considered at rest whenever its absolute velocity drops below the
     * restSpeedThreshold.
     * @public
     */

  }, {
    key: "isAtRest",
    value: function isAtRest() {
      var isAtRest = Math.abs(this._currentState.velocity) < this._restSpeedThreshold && (this.getDisplacementDistanceForState(this._currentState) <= this._displacementFromRestThreshold || this._springConfig.tension === 0);
      return isAtRest;
    }
  }, {
    key: "_interpolate",
    value: function _interpolate(alpha) {
      this._currentState.position = this._currentState.position * alpha + this._previousState.position * (1 - alpha);
      this._currentState.velocity = this._currentState.velocity * alpha + this._previousState.velocity * (1 - alpha);
    }
  }, {
    key: "addListener",
    value: function addListener(newListener) {
      this.listeners.push(newListener);
      return this;
    }
  }, {
    key: "addOneTimeListener",
    value: function addOneTimeListener(newListener) {
      var _this2 = this;

      var oneTimeFunc = function oneTimeFunc(func) {
        return function () {
          func.apply(void 0, arguments);

          _this2.removeListener(newListener);
        };
      };

      Object.keys(newListener).forEach(function (key) {
        newListener[key] = oneTimeFunc(newListener[key]);
      });
      this.listeners.push(newListener);
      return this;
    }
  }, {
    key: "removeListener",
    value: function removeListener(listenerToRemove) {
      (0, _util.removeFirst)(this.listeners, listenerToRemove);
      return this;
    }
  }]);

  return Spring;
}();

var _default = Spring;
exports.default = _default;
},{"./util":"../src/forked-rebound/util.js"}],"../src/forked-rebound/SpringSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Loopers = require("./Loopers");

var _Spring = _interopRequireDefault(require("./Spring"));

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * A set of Springs that all run on the same physics
 * timing loop. To get started with a Rebound animation, first
 * create a new SpringSystem and then add springs to it.
 * @public
 */
var SpringSystem = /*#__PURE__*/function () {
  function SpringSystem(looper) {
    _classCallCheck(this, SpringSystem);

    this.looper = looper || new _Loopers.AnimationLooper();
    this.looper.springSystem = this;
    this.listeners = [];
    this._activeSprings = [];
    this._idleSpringIndices = [];
    this._isIdle = true;
    this._lastTimeMillis = -1;
    this._springRegistry = {};
  }
  /**
   * Add a new spring to this SpringSystem. This Spring will now be solved for
   * during the physics iteration loop. By default the spring will use the
   * default Origami spring config with 40 tension and 7 friction, but you can
   * also provide your own values here.
   * @public
   */


  _createClass(SpringSystem, [{
    key: "createSpring",
    value: function createSpring(tension, friction) {
      return this.createSpringWithConfig({
        tension: tension,
        friction: friction
      });
    }
    /**
     * Add a spring with the provided SpringConfig.
     * @public
     */

  }, {
    key: "createSpringWithConfig",
    value: function createSpringWithConfig(springConfig) {
      var spring = new _Spring.default(this);
      this.registerSpring(spring);
      spring.setSpringConfig(springConfig);
      return spring;
    }
    /**
     * Check if a SpringSystem is idle or active. If all of the Springs in the
     * SpringSystem are at rest, i.e. the physics forces have reached equilibrium,
     * then this method will return true.
     * @public
     */

  }, {
    key: "getIsIdle",
    value: function getIsIdle() {
      return this._isIdle;
    }
    /**
     * Manually add a spring to this system. This is called automatically
     * if a Spring is created with SpringSystem#createSpring.
     *
     * This method sets the spring up in the registry so that it can be solved
     * in the solver loop.
     * @public
     */

  }, {
    key: "registerSpring",
    value: function registerSpring(spring) {
      this._springRegistry[spring.getId()] = spring;
    }
    /**
     * Deregister a spring with this SpringSystem. The SpringSystem will
     * no longer consider this Spring during its integration loop once
     * this is called. This is normally done automatically for you when
     * you call Spring#destroy.
     * @public
     */

  }, {
    key: "deregisterSpring",
    value: function deregisterSpring(spring) {
      (0, _util.removeFirst)(this._activeSprings, spring);
      delete this._springRegistry[spring.getId()];
    }
  }, {
    key: "advance",
    value: function advance(time, deltaTime) {
      var _this = this;

      while (this._idleSpringIndices.length > 0) {
        this._idleSpringIndices.pop();
      }

      this._activeSprings.filter(Boolean).forEach(function (spring) {
        if (spring.systemShouldAdvance()) {
          spring.advance(time / 1000.0, deltaTime / 1000.0);
        } else {
          _this._idleSpringIndices.push(_this._activeSprings.indexOf(spring));
        }
      });

      while (this._idleSpringIndices.length > 0) {
        var idx = this._idleSpringIndices.pop();

        idx >= 0 && this._activeSprings.splice(idx, 1);
      }
    }
    /**
     * This is the main solver loop called to move the simulation
     * forward through time. Before each pass in the solver loop
     * onBeforeIntegrate is called on an any listeners that have
     * registered themeselves with the SpringSystem. This gives you
     * an opportunity to apply any constraints or adjustments to
     * the springs that should be enforced before each iteration
     * loop. Next the advance method is called to move each Spring in
     * the systemShouldAdvance forward to the current time. After the
     * integration step runs in advance, onAfterIntegrate is called
     * on any listeners that have registered themselves with the
     * SpringSystem. This gives you an opportunity to run any post
     * integration constraints or adjustments on the Springs in the
     * SpringSystem.
     * @public
     */

  }, {
    key: "loop",
    value: function loop(currentTimeMillis) {
      var listener;

      if (this._lastTimeMillis === -1) {
        this._lastTimeMillis = currentTimeMillis - 1;
      }

      var ellapsedMillis = currentTimeMillis - this._lastTimeMillis;
      this._lastTimeMillis = currentTimeMillis;
      var i = 0;
      var len = this.listeners.length;

      for (i = 0; i < len; i++) {
        listener = this.listeners[i];
        listener.onBeforeIntegrate && listener.onBeforeIntegrate(this);
      }

      this.advance(currentTimeMillis, ellapsedMillis);

      if (this._activeSprings.length === 0) {
        this._isIdle = true;
        this._lastTimeMillis = -1;
      }

      for (i = 0; i < len; i++) {
        listener = this.listeners[i];
        listener.onAfterIntegrate && listener.onAfterIntegrate(this);
      }

      if (!this._isIdle) {
        this.looper.run();
      }
    }
    /**
     * Used to notify the SpringSystem that a Spring has become displaced.
     * The system responds by starting its solver loop up if it is currently idle.
     */

  }, {
    key: "activateSpring",
    value: function activateSpring(springId) {
      var spring = this._springRegistry[springId];

      if (this._activeSprings.indexOf(spring) === -1) {
        this._activeSprings.push(spring);
      }

      if (this.getIsIdle()) {
        this._isIdle = false;
        this.looper.run();
      }
    }
  }]);

  return SpringSystem;
}();

var _default = SpringSystem;
exports.default = _default;
},{"./Loopers":"../src/forked-rebound/Loopers.js","./Spring":"../src/forked-rebound/Spring.js","./util":"../src/forked-rebound/util.js"}],"../src/forked-rebound/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "SpringSystem", {
  enumerable: true,
  get: function () {
    return _SpringSystem.default;
  }
});
Object.defineProperty(exports, "onFrame", {
  enumerable: true,
  get: function () {
    return _util.onFrame;
  }
});

var _SpringSystem = _interopRequireDefault(require("./SpringSystem"));

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./SpringSystem":"../src/forked-rebound/SpringSystem.js","./util":"../src/forked-rebound/util.js"}],"../src/flip/animateFlippedElements/spring/index.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createStaggeredSprings = exports.normalizeSpeed = exports.createSpring = exports.createSuspendedSpring = void 0;

var _forkedRebound = require("../../../forked-rebound");

// this should get created only 1x
var springSystem = new _forkedRebound.SpringSystem();

var createSuspendedSpring = function createSuspendedSpring(flipData) {
  var _flipData$springConfi = flipData.springConfig,
      stiffness = _flipData$springConfi.stiffness,
      damping = _flipData$springConfi.damping,
      overshootClamping = _flipData$springConfi.overshootClamping,
      getOnUpdateFunc = flipData.getOnUpdateFunc,
      onAnimationEnd = flipData.onAnimationEnd,
      onSpringActivate = flipData.onSpringActivate;
  var spring = springSystem.createSpring(stiffness, damping);
  spring.setOvershootClampingEnabled(!!overshootClamping);

  var onSpringAtRest = function onSpringAtRest() {
    // prevent SpringSystem from caching unused springs
    spring.destroy();
    onAnimationEnd();
  };

  var springConfig = {
    onSpringActivate: onSpringActivate,
    onSpringAtRest: onSpringAtRest,
    onSpringUpdate: getOnUpdateFunc({
      spring: spring,
      onAnimationEnd: onAnimationEnd
    })
  };
  spring.addListener(springConfig);
  return spring;
};

exports.createSuspendedSpring = createSuspendedSpring;

var createSpring = function createSpring(flipped) {
  var spring = createSuspendedSpring(flipped);
  spring.setEndValue(1);
  return spring;
};

exports.createSpring = createSpring;

var normalizeSpeed = function normalizeSpeed(speedConfig) {
  if (typeof speedConfig !== 'number') return 1.1;
  return 1 + Math.min(Math.max(speedConfig * 5, 0), 5);
};

exports.normalizeSpeed = normalizeSpeed;

var createStaggeredSprings = function createStaggeredSprings(flippedArray) {
  var staggerConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!flippedArray || !flippedArray.length) {
    return;
  }

  if (staggerConfig.reverse) {
    flippedArray.reverse();
  }

  var normalizedSpeed = normalizeSpeed(staggerConfig.speed);
  var nextThreshold = 1 / Math.max(Math.min(flippedArray.length, 100), 10);
  var setEndValueFuncs = flippedArray.map(function (flipped, i) {
    var cachedGetOnUpdate = flipped.getOnUpdateFunc; // modify the update function to adjust
    // the end value of the trailing Flipped component

    flipped.getOnUpdateFunc = function (args) {
      var onUpdate = cachedGetOnUpdate(args);
      return function (spring) {
        var currentValue = spring.getCurrentValue(); // make sure trailing animations complete

        currentValue = currentValue < 0.01 ? 0 : currentValue > 0.99 ? 1 : currentValue;
        var updateTrailingAnimation = currentValue >= nextThreshold;

        if (updateTrailingAnimation) {
          if (setEndValueFuncs[i + 1]) {
            setEndValueFuncs[i + 1](Math.max(Math.min(currentValue * normalizedSpeed, 1), 0));
          }
        } // now call the actual update function


        onUpdate(spring);
      };
    };

    return flipped;
  }).map(function (flipped) {
    var spring = createSuspendedSpring(flipped);

    if (!spring) {
      return;
    }

    return spring.setEndValue.bind(spring);
  }).filter(Boolean);

  if (setEndValueFuncs[0]) {
    setEndValueFuncs[0](1);
  }
};

exports.createStaggeredSprings = createStaggeredSprings;
},{"../../../forked-rebound":"../src/forked-rebound/index.js"}],"../src/flip/animateFlippedElements/index.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.rectInViewport = exports.createApplyStylesFunc = exports.invertTransformsForChildren = exports.convertMatrix2dArrayToString = exports.convertMatrix3dArrayTo2dArray = void 0;

var Rematrix = _interopRequireWildcard(require("rematrix"));

var _springSettings = require("../../springSettings");

var _utilities = require("../../utilities");

var constants = _interopRequireWildcard(require("../../constants"));

var _spring = require("./spring");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// 3d transforms were causing weird issues in chrome,
// especially when opacity was also being tweened,
// so convert to a 2d matrix
var convertMatrix3dArrayTo2dArray = function convertMatrix3dArrayTo2dArray(matrix) {
  return [0, 1, 4, 5, 12, 13].map(function (index) {
    return matrix[index];
  });
};

exports.convertMatrix3dArrayTo2dArray = convertMatrix3dArrayTo2dArray;

var convertMatrix2dArrayToString = function convertMatrix2dArrayToString(matrix) {
  return "matrix(".concat(matrix.join(', '), ")");
};

exports.convertMatrix2dArrayToString = convertMatrix2dArrayToString;

var invertTransformsForChildren = function invertTransformsForChildren(_ref) {
  var invertedChildren = _ref.invertedChildren,
      matrix = _ref.matrix,
      body = _ref.body;
  invertedChildren.forEach(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        child = _ref3[0],
        childFlipConfig = _ref3[1];

    if (!body.contains(child)) {
      return;
    }

    var scaleX = matrix[0];
    var scaleY = matrix[3];
    var translateX = matrix[4];
    var translateY = matrix[5];
    var inverseVals = {
      translateX: 0,
      translateY: 0,
      scaleX: 1,
      scaleY: 1
    };
    var transformString = '';

    if (childFlipConfig.translate) {
      inverseVals.translateX = -translateX / scaleX;
      inverseVals.translateY = -translateY / scaleY;
      transformString += "translate(".concat(inverseVals.translateX, "px, ").concat(inverseVals.translateY, "px)");
    }

    if (childFlipConfig.scale) {
      inverseVals.scaleX = 1 / scaleX;
      inverseVals.scaleY = 1 / scaleY;
      transformString += " scale(".concat(inverseVals.scaleX, ", ").concat(inverseVals.scaleY, ")");
    }

    child.style.transform = transformString;
  });
};

exports.invertTransformsForChildren = invertTransformsForChildren;

var createApplyStylesFunc = function createApplyStylesFunc(_ref4) {
  var element = _ref4.element,
      invertedChildren = _ref4.invertedChildren,
      body = _ref4.body;
  return function (_ref5) {
    var matrix = _ref5.matrix,
        opacity = _ref5.opacity,
        forceMinVals = _ref5.forceMinVals;

    if ((0, _utilities.isNumber)(opacity)) {
      element.style.opacity = opacity + '';
    }

    if (forceMinVals) {
      element.style.minHeight = '1px';
      element.style.minWidth = '1px';
    }

    if (!matrix) {
      return;
    }

    var stringTransform = convertMatrix2dArrayToString(matrix); // always apply transform, even if identity,
    // because identity might be the starting state in a FLIP
    // transition, if the element's position is controlled by transforms

    element.style.transform = stringTransform;

    if (invertedChildren) {
      invertTransformsForChildren({
        invertedChildren: invertedChildren,
        matrix: matrix,
        body: body
      });
    }
  };
};

exports.createApplyStylesFunc = createApplyStylesFunc;

var rectInViewport = function rectInViewport(_ref6) {
  var top = _ref6.top,
      bottom = _ref6.bottom,
      left = _ref6.left,
      right = _ref6.right;
  return top < window.innerHeight && bottom > 0 && left < window.innerWidth && right > 0;
};

exports.rectInViewport = rectInViewport;

var getInvertedChildren = function getInvertedChildren(element, id) {
  return (0, _utilities.toArray)(element.querySelectorAll("[".concat(constants.DATA_INVERSE_FLIP_ID, "=\"").concat(id, "\"]")));
};

var _default = function _default(_ref7) {
  var flippedIds = _ref7.flippedIds,
      flipCallbacks = _ref7.flipCallbacks,
      inProgressAnimations = _ref7.inProgressAnimations,
      flippedElementPositionsBeforeUpdate = _ref7.flippedElementPositionsBeforeUpdate,
      flippedElementPositionsAfterUpdate = _ref7.flippedElementPositionsAfterUpdate,
      applyTransformOrigin = _ref7.applyTransformOrigin,
      spring = _ref7.spring,
      getElement = _ref7.getElement,
      debug = _ref7.debug,
      _ref7$staggerConfig = _ref7.staggerConfig,
      staggerConfig = _ref7$staggerConfig === void 0 ? {} : _ref7$staggerConfig,
      _ref7$decisionData = _ref7.decisionData,
      decisionData = _ref7$decisionData === void 0 ? {} : _ref7$decisionData,
      onComplete = _ref7.onComplete,
      containerEl = _ref7.containerEl;
  // the stuff below is used so we can return a promise that resolves when all FLIP animations have
  // completed
  var closureResolve;
  var flipCompletedPromise = new Promise(function (resolve) {
    closureResolve = resolve;
  }); // hook for users of lib to attach logic when all flip animations have completed

  if (onComplete) {
    flipCompletedPromise.then(function () {
      return onComplete(containerEl, decisionData);
    });
  }

  if (!flippedIds.length) {
    return function () {
      closureResolve([]);
      return flipCompletedPromise;
    };
  }

  var completedAnimationIds = [];
  var firstElement = getElement(flippedIds[0]); // special handling for iframes

  var body = firstElement ? firstElement.ownerDocument.querySelector('body') : document.querySelector('body');

  if ("development" !== 'production') {
    if (debug) {
      // eslint-disable-next-line no-console
      console.error('[react-flip-toolkit]\nThe "debug" prop is set to true. All FLIP animations will return at the beginning of the transition.');
    }
  }

  var duplicateFlipIds = (0, _utilities.getDuplicateValsAsStrings)(flippedIds);

  if ("development" !== 'production') {
    if (duplicateFlipIds.length) {
      // eslint-disable-next-line no-console
      console.error("[react-flip-toolkit]\nThere are currently multiple elements with the same flipId on the page.\nThe animation will only work if each Flipped component has a unique flipId.\nDuplicate flipId".concat(duplicateFlipIds.length > 1 ? 's' : '', ": ").concat(duplicateFlipIds.join('\n')));
    }
  }

  var flipDataArray = flippedIds // take all the measurements we need
  // and return an object with animation functions + necessary data
  .map(function (id) {
    var prevRect = flippedElementPositionsBeforeUpdate[id].rect;
    var currentRect = flippedElementPositionsAfterUpdate[id].rect;
    var prevOpacity = flippedElementPositionsBeforeUpdate[id].opacity;
    var currentOpacity = flippedElementPositionsAfterUpdate[id].opacity;
    var needsForcedMinVals = currentRect.width < 1 || currentRect.height < 1;
    var element = flippedElementPositionsAfterUpdate[id].element; // don't animate elements outside of the user's viewport

    if (!rectInViewport(prevRect) && !rectInViewport(currentRect)) {
      return false;
    } // this might happen if we are rapidly adding & removing elements(?)


    if (!element) {
      return false;
    }

    var flipConfig = JSON.parse(element.dataset.flipConfig);
    var springConfig = (0, _springSettings.getSpringConfig)({
      flipperSpring: spring,
      flippedSpring: flipConfig.spring
    });
    var stagger = flipConfig.stagger === true ? 'default' : flipConfig.stagger;
    var toReturn = {
      element: element,
      id: id,
      stagger: stagger,
      springConfig: springConfig
    };

    if (flipCallbacks[id] && flipCallbacks[id].shouldFlip) {
      var elementShouldFlip = flipCallbacks[id].shouldFlip(decisionData.previous, decisionData.current);

      if (!elementShouldFlip) {
        return false;
      }
    } // don't animate elements that didn't visibly change
    // but possibly animate their children


    var translateXDifference = Math.abs(prevRect.left - currentRect.left);
    var translateYDifference = Math.abs(prevRect.top - currentRect.top);
    var translateDifference = translateXDifference + translateYDifference;
    var scaleXDifference = Math.abs(prevRect.width - currentRect.width);
    var scaleYDifference = Math.abs(prevRect.height - currentRect.height);
    var scaleDifference = scaleXDifference + scaleYDifference;
    var opacityDifference = Math.abs(currentOpacity - prevOpacity);
    var differenceTooSmall = translateDifference < 0.5 && scaleDifference < 0.5 && opacityDifference < 0.01;
    var hiddenDueToDimensions = prevRect.height === 0 && currentRect.height === 0 || prevRect.width === 0 && currentRect.width === 0;

    if (hiddenDueToDimensions || differenceTooSmall) {
      return false;
    }

    var currentTransform = Rematrix.parse(flippedElementPositionsAfterUpdate[id].transform);
    var toVals = {
      matrix: currentTransform
    };
    var fromVals = {
      matrix: []
    };
    var transformsArray = [currentTransform]; // we're only going to animate the values that the child wants animated

    if (flipConfig.translate) {
      transformsArray.push(Rematrix.translateX(prevRect.left - currentRect.left));
      transformsArray.push(Rematrix.translateY(prevRect.top - currentRect.top));
    } // going any smaller than 1px breaks transitions in Chrome


    if (flipConfig.scale) {
      transformsArray.push(Rematrix.scaleX(Math.max(prevRect.width, 1) / Math.max(currentRect.width, 1)));
      transformsArray.push(Rematrix.scaleY(Math.max(prevRect.height, 1) / Math.max(currentRect.height, 1)));
    }

    if (flipConfig.opacity) {
      fromVals.opacity = prevOpacity;
      toVals.opacity = currentOpacity;
    }

    var invertedChildren = [];

    if (!flipCallbacks[id] || !flipCallbacks[id].shouldInvert || flipCallbacks[id].shouldInvert(decisionData.previous, decisionData.current)) {
      var invertedChildElements = getInvertedChildren(element, id);
      invertedChildren = invertedChildElements.map(function (c) {
        return [c, JSON.parse(c.dataset.flipConfig)];
      });
    }

    fromVals.matrix = convertMatrix3dArrayTo2dArray(transformsArray.reduce(Rematrix.multiply));
    toVals.matrix = convertMatrix3dArrayTo2dArray(toVals.matrix);
    var applyStyles = createApplyStylesFunc({
      element: element,
      invertedChildren: invertedChildren,
      body: body
    });
    var onComplete;

    if (flipCallbacks[id] && flipCallbacks[id].onComplete) {
      // must cache or else this could cause an error
      var cachedOnComplete = flipCallbacks[id].onComplete;

      onComplete = function onComplete() {
        return cachedOnComplete(element, decisionData);
      };
    } // this should be called when animation ends naturally
    // but also when it is interrupted
    // when it is called, the animation has already been cancelled


    var onAnimationEnd = function onAnimationEnd(isCancellation) {
      delete inProgressAnimations[id];

      if ((0, _utilities.isFunction)(onComplete)) {
        onComplete();
      } // remove identity transform -- this should have no effect on layout


      element.style.transform = '';
      invertedChildren.forEach(function (_ref8) {
        var _ref9 = _slicedToArray(_ref8, 1),
            element = _ref9[0];

        element.style.transform = '';
      });

      if (needsForcedMinVals && element) {
        element.style.minHeight = '';
        element.style.minWidth = '';
      }

      if (isCancellation) return;
      completedAnimationIds.push(id);

      if (completedAnimationIds.length >= flipDataArray.length) {
        // we can theoretically call multiple times since a promise only resolves 1x
        // but that shouldnt happen
        closureResolve(completedAnimationIds);
      }
    };

    var animateOpacity = (0, _utilities.isNumber)(fromVals.opacity) && (0, _utilities.isNumber)(toVals.opacity) && fromVals.opacity !== toVals.opacity;
    var onStartCalled = false;

    var getOnUpdateFunc = function getOnUpdateFunc(_ref10) {
      var spring = _ref10.spring,
          onAnimationEnd = _ref10.onAnimationEnd;
      inProgressAnimations[id] = {
        destroy: spring.destroy.bind(spring),
        onAnimationEnd: onAnimationEnd
      };

      var onUpdate = function onUpdate(spring) {
        if (flipCallbacks[id] && flipCallbacks[id].onSpringUpdate) {
          flipCallbacks[id].onSpringUpdate(spring.getCurrentValue());
        } // trigger the user provided onStart function


        if (!onStartCalled) {
          onStartCalled = true;

          if (flipCallbacks[id] && flipCallbacks[id].onStart) {
            flipCallbacks[id].onStart(element, decisionData);
          }
        }

        var currentValue = spring.getCurrentValue();

        if (!body.contains(element)) {
          spring.destroy();
          return;
        }

        var vals = {
          matrix: []
        };
        vals.matrix = fromVals.matrix.map(function (fromVal, index) {
          return (0, _utilities.tweenProp)(fromVal, toVals.matrix[index], currentValue);
        });

        if (animateOpacity) {
          vals.opacity = (0, _utilities.tweenProp)(fromVals.opacity, toVals.opacity, currentValue);
        }

        applyStyles(vals);
      };

      return onUpdate;
    };

    var initializeFlip = function initializeFlip() {
      // before animating, immediately apply FLIP styles to prevent flicker
      applyStyles({
        matrix: fromVals.matrix,
        opacity: animateOpacity ? fromVals.opacity : undefined,
        forceMinVals: needsForcedMinVals
      });

      if (flipCallbacks[id] && flipCallbacks[id].onStartImmediate) {
        flipCallbacks[id].onStartImmediate(element, decisionData);
      } // and batch any other style updates if necessary


      if (flipConfig.transformOrigin) {
        element.style.transformOrigin = flipConfig.transformOrigin;
      } else if (applyTransformOrigin) {
        element.style.transformOrigin = '0 0';
      }

      invertedChildren.forEach(function (_ref11) {
        var _ref12 = _slicedToArray(_ref11, 2),
            child = _ref12[0],
            childFlipConfig = _ref12[1];

        if (childFlipConfig.transformOrigin) {
          child.style.transformOrigin = childFlipConfig.transformOrigin;
        } else if (applyTransformOrigin) {
          child.style.transformOrigin = '0 0';
        }
      });
    };

    return (0, _utilities.assign)({}, toReturn, {
      stagger: stagger,
      springConfig: springConfig,
      getOnUpdateFunc: getOnUpdateFunc,
      initializeFlip: initializeFlip,
      onAnimationEnd: onAnimationEnd,
      delayUntil: flipConfig.delayUntil
    });
  }) // filter out data for all non-animated elements first
  .filter(Boolean);
  flipDataArray.forEach(function (_ref13) {
    var initializeFlip = _ref13.initializeFlip;
    return initializeFlip();
  });

  if (debug) {
    return function () {};
  }

  var elementIsFlipped = function elementIsFlipped(flipId) {
    return flipDataArray.filter(function (f) {
      return f.id === flipId;
    }).length;
  };

  var delayedFlip = flipDataArray.filter(function (f) {
    return f.delayUntil && elementIsFlipped(f.delayUntil);
  }); // key: flipId value: flip to delay until key is called

  var delayUntilSprings = {}; // key: flipId value: stagger to delay until key is called

  var delayUntilStaggers = {}; // key: stagger value: true

  var delayedStaggerKeys = {};
  delayedFlip.forEach(function (flip) {
    if (flip.stagger) {
      delayedStaggerKeys[flip.stagger] = true;
      if (delayUntilStaggers[flip.delayUntil]) delayUntilStaggers[flip.delayUntil].push(flip.stagger);else delayUntilStaggers[flip.delayUntil] = [flip.stagger];
    } else {
      if (delayUntilSprings[flip.delayUntil]) delayUntilSprings[flip.delayUntil].push(flip);else delayUntilSprings[flip.delayUntil] = [flip];
    }
  });
  var staggerDict = flipDataArray.filter(function (flipData) {
    return flipData.stagger;
  }).reduce(function (acc, curr) {
    if (acc[curr.stagger]) {
      acc[curr.stagger].push(curr);
    } else {
      acc[curr.stagger] = [curr];
    }

    return acc;
  }, {});
  var immediateFlip = flipDataArray.filter(function (f) {
    return delayedFlip.indexOf(f) === -1;
  });
  immediateFlip.forEach(function (flipData) {
    flipData.onSpringActivate = function () {
      if (delayUntilSprings[flipData.id]) {
        delayUntilSprings[flipData.id].forEach(_spring.createSpring);
      }

      if (delayUntilStaggers[flipData.id]) {
        var uniqueStaggerKeys = Object.keys(delayUntilStaggers[flipData.id].reduce(function (acc, curr) {
          return (0, _utilities.assign)(acc, _defineProperty({}, curr, true));
        }, {}));
        uniqueStaggerKeys.forEach(function (staggerKey) {
          (0, _spring.createStaggeredSprings)(staggerDict[staggerKey], staggerConfig[staggerKey]);
        });
      }
    };
  });
  return function () {
    // if there are no active FLIP animations, immediately resolve the
    // returned promise
    if (!flipDataArray.length) {
      closureResolve([]);
    } // animate non-staggered elements


    immediateFlip.filter(function (flipData) {
      return !flipData.stagger;
    }).forEach(_spring.createSpring); // animate staggered elements

    Object.keys(staggerDict).forEach(function (staggerKey) {
      if (delayedStaggerKeys[staggerKey]) return;
      (0, _spring.createStaggeredSprings)(staggerDict[staggerKey], staggerConfig[staggerKey]);
    });
    return flipCompletedPromise;
  };
};

exports.default = _default;
},{"rematrix":"../../../node_modules/rematrix/dist/rematrix.es.js","../../springSettings":"../src/springSettings/index.ts","../../utilities":"../src/utilities/index.ts","../../constants":"../src/constants.ts","./spring":"../src/flip/animateFlippedElements/spring/index.ts"}],"../src/flip/getFlippedElementPositions/utilities.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRects = exports.getAllElements = exports.addTupleToObject = void 0;

var _utilities = require("../../utilities");

var constants = _interopRequireWildcard(require("../../constants"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var addTupleToObject = function addTupleToObject(acc, curr) {
  return (0, _utilities.assign)(acc, _defineProperty({}, curr[0], curr[1]));
};

exports.addTupleToObject = addTupleToObject;

var getAllElements = function getAllElements(element, portalKey) {
  if (portalKey) {
    return (0, _utilities.toArray)(document.querySelectorAll("[".concat(constants.DATA_PORTAL_KEY, "=\"").concat(portalKey, "\"]")));
  } else {
    return (0, _utilities.toArray)(element.querySelectorAll("[".concat(constants.DATA_FLIP_ID, "]")));
  }
};

exports.getAllElements = getAllElements;

var getRects = function getRects(flippedElements) {
  return flippedElements.map(function (child) {
    return [child, child.getBoundingClientRect()];
  });
};

exports.getRects = getRects;
},{"../../utilities":"../src/utilities/index.ts","../../constants":"../src/constants.ts"}],"../src/flip/getFlippedElementPositions/getFlippedElementPositionsAfterUpdate/index.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utilities = require("../utilities");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var getFlippedElementPositionsAfterUpdate = function getFlippedElementPositionsAfterUpdate(_ref) {
  var element = _ref.element,
      portalKey = _ref.portalKey;
  var positionArray = (0, _utilities.getRects)((0, _utilities.getAllElements)(element, portalKey)).map(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        child = _ref3[0],
        childBCR = _ref3[1];

    var computedStyle = window.getComputedStyle(child);
    return [child.dataset.flipId, {
      element: child,
      rect: childBCR,
      opacity: parseFloat(computedStyle.opacity),
      transform: computedStyle.transform
    }];
  });
  return positionArray.reduce(_utilities.addTupleToObject, {});
};

var _default = getFlippedElementPositionsAfterUpdate;
exports.default = _default;
},{"../utilities":"../src/flip/getFlippedElementPositions/utilities.ts"}],"../src/flip/index.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _animateUnflippedElements = _interopRequireDefault(require("./animateUnflippedElements"));

var _animateFlippedElements = _interopRequireDefault(require("./animateFlippedElements"));

var _getFlippedElementPositionsAfterUpdate = _interopRequireDefault(require("./getFlippedElementPositions/getFlippedElementPositionsAfterUpdate"));

var constants = _interopRequireWildcard(require("../constants"));

var _utilities = require("../utilities");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createPortalScopedSelector = function createPortalScopedSelector(portalKey) {
  return function (selector) {
    return (0, _utilities.toArray)(document.querySelectorAll("[".concat(constants.DATA_PORTAL_KEY, "=\"").concat(portalKey, "\"]").concat(selector)));
  };
};

var createFlipperScopedSelector = function createFlipperScopedSelector(containerEl) {
  var tempFlipperId = Math.random().toFixed(5);
  containerEl.dataset.flipperId = tempFlipperId;
  return function (selector) {
    return (0, _utilities.toArray)(containerEl.querySelectorAll("[data-flipper-id=\"".concat(tempFlipperId, "\"] ").concat(selector)));
  };
};

var createScopedSelector = function createScopedSelector(_ref) {
  var containerEl = _ref.containerEl,
      portalKey = _ref.portalKey;

  if (portalKey) {
    return createPortalScopedSelector(portalKey);
  } else if (containerEl) {
    return createFlipperScopedSelector(containerEl);
  } else {
    return function () {
      return [];
    };
  }
};

var createGetElementFunc = function createGetElementFunc(scopedSelector) {
  return function (id) {
    return scopedSelector("[".concat(constants.DATA_FLIP_ID, "=\"").concat(id, "\"]"))[0];
  };
};

var onFlipKeyUpdate = function onFlipKeyUpdate(_ref2) {
  var _ref2$cachedOrderedFl = _ref2.cachedOrderedFlipIds,
      cachedOrderedFlipIds = _ref2$cachedOrderedFl === void 0 ? [] : _ref2$cachedOrderedFl,
      _ref2$inProgressAnima = _ref2.inProgressAnimations,
      inProgressAnimations = _ref2$inProgressAnima === void 0 ? {} : _ref2$inProgressAnima,
      _ref2$flippedElementP = _ref2.flippedElementPositionsBeforeUpdate,
      flippedElementPositionsBeforeUpdate = _ref2$flippedElementP === void 0 ? {} : _ref2$flippedElementP,
      _ref2$flipCallbacks = _ref2.flipCallbacks,
      flipCallbacks = _ref2$flipCallbacks === void 0 ? {} : _ref2$flipCallbacks,
      containerEl = _ref2.containerEl,
      applyTransformOrigin = _ref2.applyTransformOrigin,
      spring = _ref2.spring,
      debug = _ref2.debug,
      portalKey = _ref2.portalKey,
      _ref2$staggerConfig = _ref2.staggerConfig,
      staggerConfig = _ref2$staggerConfig === void 0 ? {} : _ref2$staggerConfig,
      _ref2$decisionData = _ref2.decisionData,
      decisionData = _ref2$decisionData === void 0 ? {} : _ref2$decisionData,
      handleEnterUpdateDelete = _ref2.handleEnterUpdateDelete,
      onComplete = _ref2.onComplete,
      onStart = _ref2.onStart;
  var flippedElementPositionsAfterUpdate = (0, _getFlippedElementPositionsAfterUpdate.default)({
    element: containerEl,
    portalKey: portalKey
  });
  var scopedSelector = createScopedSelector({
    containerEl: containerEl,
    portalKey: portalKey
  });
  var getElement = createGetElementFunc(scopedSelector);

  var isFlipped = function isFlipped(id) {
    return flippedElementPositionsBeforeUpdate[id] && flippedElementPositionsAfterUpdate[id];
  };

  var unflippedIds = Object.keys(flippedElementPositionsBeforeUpdate).concat(Object.keys(flippedElementPositionsAfterUpdate)).filter(function (id) {
    return !isFlipped(id);
  });
  var baseArgs = {
    flipCallbacks: flipCallbacks,
    getElement: getElement,
    flippedElementPositionsBeforeUpdate: flippedElementPositionsBeforeUpdate,
    flippedElementPositionsAfterUpdate: flippedElementPositionsAfterUpdate,
    inProgressAnimations: inProgressAnimations,
    decisionData: decisionData
  };
  var animateUnFlippedElementsArgs = (0, _utilities.assign)({}, baseArgs, {
    unflippedIds: unflippedIds
  });

  var _animateUnflippedElem = (0, _animateUnflippedElements.default)(animateUnFlippedElementsArgs),
      hideEnteringElements = _animateUnflippedElem.hideEnteringElements,
      animateEnteringElements = _animateUnflippedElem.animateEnteringElements,
      animateExitingElements = _animateUnflippedElem.animateExitingElements;

  var flippedIds = cachedOrderedFlipIds.filter(isFlipped); // @ts-ignore

  var animateFlippedElementsArgs = (0, _utilities.assign)({}, baseArgs, {
    containerEl: containerEl,
    flippedIds: flippedIds,
    applyTransformOrigin: applyTransformOrigin,
    spring: spring,
    debug: debug,
    staggerConfig: staggerConfig,
    scopedSelector: scopedSelector,
    onComplete: onComplete
  });
  if (onStart) onStart(containerEl, decisionData); // the function handles putting flipped elements back in their original positions
  // and returns another function to actually call the flip animation

  var flip = (0, _animateFlippedElements.default)(animateFlippedElementsArgs);

  if (handleEnterUpdateDelete) {
    handleEnterUpdateDelete({
      hideEnteringElements: hideEnteringElements,
      animateEnteringElements: animateEnteringElements,
      animateExitingElements: animateExitingElements,
      animateFlippedElements: flip
    });
  } else {
    hideEnteringElements();
    animateExitingElements().then(animateEnteringElements);
    flip();
  }
};

var _default = onFlipKeyUpdate;
exports.default = _default;
},{"./animateUnflippedElements":"../src/flip/animateUnflippedElements/index.ts","./animateFlippedElements":"../src/flip/animateFlippedElements/index.ts","./getFlippedElementPositions/getFlippedElementPositionsAfterUpdate":"../src/flip/getFlippedElementPositions/getFlippedElementPositionsAfterUpdate/index.ts","../constants":"../src/constants.ts","../utilities":"../src/utilities/index.ts"}],"../src/flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate/index.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.cancelInProgressAnimations = void 0;

var _utilities = require("../utilities");

var constants = _interopRequireWildcard(require("../../../constants"));

var _utilities2 = require("../../../utilities");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var cancelInProgressAnimations = function cancelInProgressAnimations(inProgressAnimations, animatingElements) {
  Object.keys(inProgressAnimations).forEach(function (id) {
    if (inProgressAnimations[id].destroy) {
      inProgressAnimations[id].destroy();
    }

    if (inProgressAnimations[id].onAnimationEnd) {
      inProgressAnimations[id].onAnimationEnd(true);
    }

    delete inProgressAnimations[id];
  });
  animatingElements.forEach(function (el) {
    el.style.transform = '';
    el.style.opacity = '';
  });
};

exports.cancelInProgressAnimations = cancelInProgressAnimations;

var getFlippedElementPositionsBeforeUpdate = function getFlippedElementPositionsBeforeUpdate(_ref) {
  var element = _ref.element,
      _ref$flipCallbacks = _ref.flipCallbacks,
      flipCallbacks = _ref$flipCallbacks === void 0 ? {} : _ref$flipCallbacks,
      _ref$inProgressAnimat = _ref.inProgressAnimations,
      inProgressAnimations = _ref$inProgressAnimat === void 0 ? {} : _ref$inProgressAnimat,
      portalKey = _ref.portalKey;
  var flippedElements = (0, _utilities.getAllElements)(element, portalKey);
  var inverseFlippedElements = (0, _utilities2.toArray)(element.querySelectorAll("[".concat(constants.DATA_INVERSE_FLIP_ID, "]")));
  var childIdsToParentBCRs = {};
  var parentBCRs = [];
  var childIdsToParents = {}; // this is for exit animations so we can re-insert exiting elements in the
  // DOM later

  flippedElements.filter(function (el) {
    return flipCallbacks && flipCallbacks[el.dataset.flipId] && flipCallbacks[el.dataset.flipId].onExit;
  }).forEach(function (el) {
    var parent = el.parentNode; // this won't work for IE11

    if (el.closest) {
      var exitContainer = el.closest("[".concat(constants.DATA_EXIT_CONTAINER, "]"));

      if (exitContainer) {
        parent = exitContainer;
      }
    }

    var bcrIndex = parentBCRs.findIndex(function (n) {
      return n[0] === parent;
    });

    if (bcrIndex === -1) {
      parentBCRs.push([parent, parent.getBoundingClientRect()]);
      bcrIndex = parentBCRs.length - 1;
    }

    childIdsToParentBCRs[el.dataset.flipId] = parentBCRs[bcrIndex][1];
    childIdsToParents[el.dataset.flipId] = parent;
  });
  var filteredFlippedElements = (0, _utilities.getRects)(flippedElements);
  var flippedElementPositionsTupleArray = filteredFlippedElements.map(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        child = _ref3[0],
        childBCR = _ref3[1];

    var domDataForExitAnimations = {}; // only cache extra data for exit animations
    // if the element has an onExit listener

    if (flipCallbacks && flipCallbacks[child.dataset.flipId] && flipCallbacks[child.dataset.flipId].onExit) {
      var parentBCR = childIdsToParentBCRs[child.dataset.flipId];
      (0, _utilities2.assign)(domDataForExitAnimations, {
        element: child,
        parent: childIdsToParents[child.dataset.flipId],
        childPosition: {
          top: childBCR.top - parentBCR.top,
          left: childBCR.left - parentBCR.left,
          width: childBCR.width,
          height: childBCR.height
        }
      });
    }

    return [child.dataset.flipId, {
      rect: childBCR,
      opacity: parseFloat(window.getComputedStyle(child).opacity || '1'),
      domDataForExitAnimations: domDataForExitAnimations
    }];
  });
  var flippedElementPositions = flippedElementPositionsTupleArray.reduce(_utilities.addTupleToObject, {}); // do this at the very end since we want to cache positions of elements
  // while they are mid-transition

  cancelInProgressAnimations(inProgressAnimations, flippedElements.concat(inverseFlippedElements));
  return {
    flippedElementPositions: flippedElementPositions,
    cachedOrderedFlipIds: filteredFlippedElements.map(function (_ref4) {
      var _ref5 = _slicedToArray(_ref4, 1),
          el = _ref5[0];

      return el.dataset.flipId;
    })
  };
};

var _default = getFlippedElementPositionsBeforeUpdate;
exports.default = _default;
},{"../utilities":"../src/flip/getFlippedElementPositions/utilities.ts","../../../constants":"../src/constants.ts","../../../utilities":"../src/utilities/index.ts"}],"../src/Flipper.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _flip = _interopRequireDefault(require("./flip"));

var _getFlippedElementPositionsBeforeUpdate = _interopRequireDefault(require("./flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate"));

var _utilities = require("./utilities");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Flipper = /*#__PURE__*/function () {
  function Flipper(options) {
    _classCallCheck(this, Flipper);

    this.applyTransformOrigin = true;
    (0, _utilities.assign)(this, options);
    this.inProgressAnimations = {};
    this.flipCallbacks = {};
    this.recordBeforeUpdate = this.recordBeforeUpdate.bind(this);
    this.update = this.update.bind(this);
    this.addFlipped = this.addFlipped.bind(this);
    this.addInverted = this.addInverted.bind(this);
  }

  _createClass(Flipper, [{
    key: "recordBeforeUpdate",
    value: function recordBeforeUpdate() {
      this.snapshot = (0, _getFlippedElementPositionsBeforeUpdate.default)({
        element: this.element,
        flipCallbacks: this.flipCallbacks,
        inProgressAnimations: this.inProgressAnimations
      });
    }
  }, {
    key: "update",
    value: function update(prevDecisionData, currentDecisionData) {
      if (this.snapshot) {
        (0, _flip.default)({
          flippedElementPositionsBeforeUpdate: this.snapshot.flippedElementPositions,
          cachedOrderedFlipIds: this.snapshot.cachedOrderedFlipIds,
          containerEl: this.element,
          inProgressAnimations: this.inProgressAnimations,
          flipCallbacks: this.flipCallbacks,
          applyTransformOrigin: this.applyTransformOrigin,
          spring: this.spring,
          debug: this.debug,
          staggerConfig: this.staggerConfig,
          handleEnterUpdateDelete: this.handleEnterUpdateDelete,
          decisionData: {
            previous: prevDecisionData,
            current: currentDecisionData
          },
          onComplete: this.onComplete,
          onStart: this.onStart
        });
        delete this.snapshot;
      }
    }
  }, {
    key: "addFlipped",
    value: function addFlipped(_ref) {
      var element = _ref.element,
          flipId = _ref.flipId,
          opacity = _ref.opacity,
          translate = _ref.translate,
          scale = _ref.scale,
          transformOrigin = _ref.transformOrigin,
          spring = _ref.spring,
          stagger = _ref.stagger,
          delayUntil = _ref.delayUntil,
          onAppear = _ref.onAppear,
          onStart = _ref.onStart,
          onSpringUpdate = _ref.onSpringUpdate,
          onComplete = _ref.onComplete,
          onExit = _ref.onExit,
          shouldFlip = _ref.shouldFlip,
          shouldInvert = _ref.shouldInvert;

      if (!element) {
        throw new Error('no element provided');
      }

      if (!flipId) {
        throw new Error('No flipId provided');
      }

      var flipConfig = {
        scale: scale,
        translate: translate,
        opacity: opacity,
        transformOrigin: transformOrigin,
        spring: spring,
        stagger: stagger,
        delayUntil: delayUntil
      };

      if (!flipConfig.scale && !flipConfig.translate && !flipConfig.opacity) {
        (0, _utilities.assign)(flipConfig, {
          translate: true,
          scale: true,
          opacity: true
        });
      }

      if (flipId) {
        element.dataset.flipId = String(flipId);
      }

      element.dataset.flipConfig = JSON.stringify(flipConfig); // finally, add callbacks

      this.flipCallbacks[flipId] = {
        shouldFlip: shouldFlip,
        shouldInvert: shouldInvert,
        onAppear: onAppear,
        onStart: onStart,
        onSpringUpdate: onSpringUpdate,
        onComplete: onComplete,
        onExit: onExit
      };
    }
  }, {
    key: "addInverted",
    value: function addInverted(_ref2) {
      var element = _ref2.element,
          parent = _ref2.parent,
          opacity = _ref2.opacity,
          translate = _ref2.translate,
          scale = _ref2.scale,
          transformOrigin = _ref2.transformOrigin;

      if (!element) {
        throw new Error('no element provided');
      }

      if (!parent) {
        throw new Error('parent must be provided');
      }

      var inverseFlipId = parent.dataset.flipId;
      var flipConfig = {
        scale: scale,
        translate: translate,
        opacity: opacity,
        transformOrigin: transformOrigin
      };

      if (!flipConfig.scale && !flipConfig.translate && !flipConfig.opacity) {
        (0, _utilities.assign)(flipConfig, {
          translate: true,
          scale: true,
          opacity: true
        });
      }

      element.dataset.inverseFlipId = inverseFlipId;
      element.dataset.flipConfig = JSON.stringify(flipConfig);
    }
  }]);

  return Flipper;
}();

var _default = Flipper;
exports.default = _default;
},{"./flip":"../src/flip/index.ts","./flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate":"../src/flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate/index.ts","./utilities":"../src/utilities/index.ts"}],"../src/Spring/index.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _forkedRebound = require("../forked-rebound");

var _utilities = require("../utilities");

var _springSettings = require("../springSettings");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// this should get created only 1x
var springSystem = new _forkedRebound.SpringSystem();
/**
 * A simple spring function for animating DOM properties.
 * Returns a function that will immediately cancel the in-progress animation.
 * */

var createSimpleSpring = function createSimpleSpring(_ref) {
  var config = _ref.config,
      values = _ref.values,
      onUpdate = _ref.onUpdate,
      _ref$delay = _ref.delay,
      delay = _ref$delay === void 0 ? 0 : _ref$delay,
      onComplete = _ref.onComplete;

  var _assign = (0, _utilities.assign)({}, _springSettings.springPresets.noWobble, (0, _springSettings.normalizeSpring)(config)),
      stiffness = _assign.stiffness,
      damping = _assign.damping,
      overshootClamping = _assign.overshootClamping;

  var spring = springSystem.createSpring(stiffness, damping);
  spring.setOvershootClampingEnabled(!!overshootClamping);
  spring.addListener({
    onSpringAtRest: function onSpringAtRest(spring) {
      if (onComplete) onComplete();
      spring.destroy();
    },
    onSpringUpdate: function onSpringUpdate(spring) {
      var springVal = spring.getCurrentValue();
      if (!values) return onUpdate(springVal);
      var currentValues = Object.keys(values).map(function (value) {
        return [value, (0, _utilities.tweenProp)(values[value][0], values[value][1], springVal)];
      }).reduce(function (acc, curr) {
        return Object.assign(acc, _defineProperty({}, curr[0], curr[1]));
      }, {});
      onUpdate(currentValues);
    }
  });

  if (delay) {
    setTimeout(function () {
      spring.setEndValue(1);
    }, delay);
  } else {
    spring.setEndValue(1);
  }

  return spring;
};

var _default = createSimpleSpring;
exports.default = _default;
},{"../forked-rebound":"../src/forked-rebound/index.js","../utilities":"../src/utilities/index.ts","../springSettings":"../src/springSettings/index.ts"}],"../src/index.ts":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Flipper", {
  enumerable: true,
  get: function () {
    return _Flipper.default;
  }
});
Object.defineProperty(exports, "getFlippedElementPositionsBeforeUpdate", {
  enumerable: true,
  get: function () {
    return _getFlippedElementPositionsBeforeUpdate.default;
  }
});
Object.defineProperty(exports, "onFlipKeyUpdate", {
  enumerable: true,
  get: function () {
    return _flip.default;
  }
});
Object.defineProperty(exports, "spring", {
  enumerable: true,
  get: function () {
    return _Spring.default;
  }
});
exports.constants = exports.utilities = void 0;

var utilities = _interopRequireWildcard(require("./utilities"));

exports.utilities = utilities;

var constants = _interopRequireWildcard(require("./constants"));

exports.constants = constants;

var _Flipper = _interopRequireDefault(require("./Flipper"));

var _getFlippedElementPositionsBeforeUpdate = _interopRequireDefault(require("./flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate"));

var _flip = _interopRequireDefault(require("./flip"));

var _Spring = _interopRequireDefault(require("./Spring"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./utilities":"../src/utilities/index.ts","./constants":"../src/constants.ts","./Flipper":"../src/Flipper.ts","./flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate":"../src/flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate/index.ts","./flip":"../src/flip/index.ts","./Spring":"../src/Spring/index.ts"}],"index.js":[function(require,module,exports) {
"use strict";

var _index = require("../src/index.ts");

var container = document.querySelector('.container');
var box = document.querySelector('.box');
var innerBox = document.querySelector('.innerBox');
var flipper = new _index.Flipper({
  element: container
});
box.addEventListener('click', function () {
  flipper.recordBeforeUpdate();
  box.classList.toggle('big-box');
  flipper.update();
});
flipper.addFlipped({
  element: box,
  flipId: 'box',
  inverted: innerBox,
  shouldFlip: function shouldFlip() {
    console.log('shouldFlip called');
    return true;
  },
  shouldInvert: function shouldInvert() {
    console.log('shouldInvert called');
    return true;
  }
});
flipper.addInverted({
  element: innerBox,
  parent: box
});
var container2 = document.querySelector('.container-2');
var flipper2 = new _index.Flipper({
  element: container2,
  spring: {
    stiffness: 4,
    damping: 4
  }
});
container2.addEventListener('click', function () {
  flipper2.recordBeforeUpdate();
  container2.classList.toggle('reversed');
  flipper2.update();
});
Array.from(container2.querySelectorAll('li')).forEach(function (li, i) {
  flipper2.addFlipped({
    element: li,
    flipId: "li-".concat(i),
    stagger: true
  });
});
Array.from(container2.querySelectorAll('.container-2 .inner')).forEach(function (div, i) {
  flipper2.addFlipped({
    element: div,
    flipId: "inner-".concat(i),
    delayUntil: "li-".concat(i)
  });
});
Array.from(container2.querySelectorAll('.container-2 .inverted')).forEach(function (div, i) {
  flipper2.addInverted({
    element: div,
    parent: div.parentNode
  });
});
},{"../src/index.ts":"../src/index.ts"}],"../../../node_modules/parcel/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "65516" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["../../../node_modules/parcel/src/builtins/hmr-runtime.js","index.js"], null)
//# sourceMappingURL=/test.e31bb0bc.js.map